---
layout: post
title: 8.6 데이터 전송과 처리
subheading: Data Transfer and Manipulation
author: JunHo
categories: 컴퓨터구조
banner: https://bit.ly/32PAjtM
tags: 컴퓨터구조 컴퓨터설계 Program 프로그램 Data transfer manipulation
sitemap :
  changefreq : daily
  priority : 1.0



---



## 8.8 간소화된 명령어 집합 컴퓨터

---

### 중첩된 레지스터 윈도우 (Overlapped Register Windows)

- 레지스터 윈도우는 한번에 단 하나의 값만 활성화 된다.
- - 활성화된 레지스터 윈도우를 포인터가 가리키는 형태로 동작한다.
- 어떤함수가 호출되었을 때, 그 때 새로운 레지스터 윈도우가 활성화 된다.
- - 새로 활성화된 윈도우를 가리키기 위해서 포인터가 하나 증가된 형태로 동작한다.
- 어떤 함수가 새로운 함수를 호출할 때, 호출된 함수의 윈도우는 상위 넘버를 갖는 레지스터는 공유한다. 호출된 함수와 공유가 되고, 호출된 함수에서 레지스터 윈도우에 있는 하위 넘버에 있는 레지스터와 공유된다.
- 이 방식은 호출한 함수의 위쪽과 호출한 함수의 아래쪽과 서로 겹친다. 따라서 파라미터 들이나 결과값들을 전달하느 형태로 사용될 수 있다.

- 추가적으로 중첩된 레지스터 윈도우 뿐만 아니라, 프로세서는 글로벌 레지스터도 가지고 있다. 물론 이 숫자는 매번 달라질 수 있다. 하지만 전역변수에 해당하는 글로벌 레지스터에 모든 함수가 접근할 수 있다.
- 오버랩 레지스터 윈도우의 장점은 어떤 함수가 호출되었을 때 프로세서가 값을 저장하거나 또는 파라미터를 전달하기 위해서 스택에 레지스터에 있는 값들을 푸쉬할 필요가 없다. 반대로 함수가 반환될때 스택에 있는 값들을 퍼내기만 하면 된다. 
- - 이런 형태로 중첩된 레지스터 윈도우를 사용할 떄 스택에 접근하기 위해서 메모리에 접근하는 과정을 줄일 수 있다. 
  - 레지스터에 있는 내용들을 복사하는 비용이 없다.
- 사실은 함수가 호출되고 반환되는 동작이 흔히 일어난다. 호출과 반환에 해당하는 동작이 줄어들면 줄어들수록 프로그램이 더 빨리 실행된다. 중첩된 레지스터 윈도우를 사용하게 되면 스택 베이스에 해당하는 접근방식보다는 상대적으로 상당한 자원이 절약된다.



### RISC I H/W 구성

- RISC 구조에서 가장 처음에 그 구조의 장점이 실제로 있다고 보이기 위해서 RISC 1 이라느 구조를 제안했다. 이 RISC 하드웨어 구조는 다음과 같은 구성을 가지고 있다.
- CPU 집적회로로 이루어진 32비트
- 주소 32비트 사용
- 데이터는 8비트, 16비트, 32비트 모두 사용한다
- 명령어 포맷은 32비트로 이루어져 있다.
- 명령어의 개수는 31개
- 어드레싱 모드는 3개를 사용한다.
- - 레지스터 어드레스 방식
  - Immediate
  - PC relative addressing
- 138개 레지스터 사용
- - 10개는 글로벌 레지스터
  - 32개의 레지스터를 가지고 있는 8개의 윈도우로 이루어져 있다.
  - window = L+2C+G    32 = 22+10
  - 138 = G + (L + C) * 8
  - G=10, L+C=16, L+2C=22, C=6, L=10

#### 명령어 포맷

- 주소 모드에 따라서 3가지 형태로 구분할 수 있다.

![K-056](https://user-images.githubusercontent.com/38898759/119849924-05c0bd00-bf48-11eb-9c22-bfa9084c091b.png)

- 레지스터 모드 : 주소값에 해당하는 것 대신 특정한 피연산자가 저장되어 있는 레지스터 위치를 나타낸다. (S2가 특정한 레지스터를 나타내는 형태로 동작한다)

- - Rs에 있는 값과 S2에 있는 값을 가지고 와서 연산을 하고 그 결과를 Rd에 저장한다.

- 즉시 모드 : 피연산자가 명령어에 포함되어 있는 형태, (S2가 피연산자인 형태)
- - 13번쨰 있는 값이 0이면 레지스터 모드, 1이면 즉시 모드
- PC 상대주소 모드 : 특정한 주소 값에 상대적으로 얼마만큼 더해야 하는지 빼야하는지 이런 형태로 동작. (Y에 상대주소가 저장되어 있다.) 
- - Rd부분이 Condition 필드로 사용됨
  - Y는 상대주소를 저장하는 공간

Rd = Register of destination

Rs = Register of Source



- 레지스터 0은 0값을 저장하는 데 사용한다.
- 필요한 경우 어떤 값들을 저장하거나 다른 레지스터의 내용을 전달하는데 중간 기착지로 사용하는 레지스터다.
- 8개의 메모리 접근 명령어를 제공한다.
- - 5개는 메모리로부터 로드하는 명령어
  - 3개는 메모리에 저장하는 명령어

![K-057](https://user-images.githubusercontent.com/38898759/119851227-335a3600-bf49-11eb-8c39-1160fde6728b.png)

 ![K-059](https://user-images.githubusercontent.com/38898759/119851863-c09d8a80-bf49-11eb-9903-933910596693.png)메몰

- 메모리에 접근하는 명령어는 명령어의 길이에 따라서 서로 다른 동작이 일어날 수 있다.
- - Long 타입의 경우는 32비트이다. 레지스터에 저장된것도 32비트이다. long 타입으로 로드할 때는 단순하게 로드된다.
  - short나 byte로 로드하면 좀 복잡하다.
  - - 부호가 있냐 없냐에 따라서 달라진다.
    - 부호가 없을 경우 - 상위를 모두 0으로 채워준다. byte의 경우 상위 24개를 0으로 채운다.
    - 부호가 있을 경우 - 로드되는 short, byte의 부호비트가 로드된다. 그래서 만약에 양수라면 모든 값이 0으로 상위 비트가 채워지고 음수면 모두 1로 상위비트가 채워진다.

![K-060](https://user-images.githubusercontent.com/38898759/119852389-386bb500-bf4a-11eb-8834-44ca58d9dcfe.png)

- 상대주소 모드로 메모리에 접근한다.



버클리 RISC 1 명령어

![K-061](https://user-images.githubusercontent.com/38898759/119852766-8da7c680-bf4a-11eb-9711-b849ad2ea862.png)

데이터 조작 명령어다

![K-062](https://user-images.githubusercontent.com/38898759/119852947-b5972a00-bf4a-11eb-8ba2-cbfe9e0aad1b.png)

데이터 전송 명령어다



![K-063](https://user-images.githubusercontent.com/38898759/119853693-630a3d80-bf4b-11eb-9bb1-b5771d102f9e.png)

프로그램의 순서를 제어하는 PC의 값을 조작하는 명령어들


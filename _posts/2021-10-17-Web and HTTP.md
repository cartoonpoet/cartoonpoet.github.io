---
layout: post
title: 웹과 HTTP
subheading: Web and HTTP
author: JunHo
categories: 분산처리
banner: https://bit.ly/32PAjtM
tags: 분산 시스템 네트워크 System distributed issues 정의 시스템 모델 XML DTD
sitemap :
  changefreq : daily
  priority : 1.0






---





### Web과 HTTP

- 웹은 필요할때 운영한다.
- - 사용자는 원할 때 원하는 것을 받는다.
- 웹 페이지는 객체로 구성되어 있다.
- 웹페이지는 여러 개의 참조 오브젝트를 포함하는 기본 HTML 파일로 구성되어 있다.
- 오브젝트는 파일이다. - HTML 파일, JPEG, JAVA 애플릿, 비디오
- 각 객체는 URL로 주소 지정 가능
- 각 URL에는 두가지 구성요소가 있다.,
- - www.someschool.edu/someDept/pic.gif
  - ​            호스트명            /       경로명



### HTTP 개요

- HTTP : hypertext transfer protocol
- 웹의 애플리케이션 레이어 프로토콜
- 클라이언트/서버 모델
- - 두 프로그램 안에서 실행 됨 : 클라이언트 프로그램과 서버 프로그램
  - 웹브라우저는 HTTP의 클라이언트 사이드에서 실행된다
  - 웹 서버는 HTTP의 서버 사이드에서 실행된다.
- HTTP 정의
- - 어떻게 웹 클라이언트가 웹서버로부터 웹페이지를 요청하는지
  - 어떻게 웹서버가 웹 클라이언트에게 웹페이지를 전송하는지
- 클라이언트 : 웹 브라우저를 요청하고 받는다 (HTTP 프로토콜을 사용하여) 그리고 웹 오브젝트를 보여준다.
- 서버  : 웹 서버는 HTTP 프로토콜을 사용하여 요청의 응답으로 객체를 전송한다. 

- TCP를 기본 전송 프로토콜로 사용한다.
- - HTTP 클라이언트는 서버, 포트 80에 TCP 연결(소켓 생성)을 개시한다.
  - 서버는 클라이언트로부터 TCP 연결을 받아들임
  - 접속이 완료되면 브라우저와 서버는 소켓 인터페이스를 통해 TCP접속을 처리함
- 클라이언트는 소켓 인터페이스에 HTTP 요청을 보내고 소켓 인터페이스에서 HTTP 응답 메시지를 수신한다.
- 서버는 소켓 인터페이스로부터 HTTP 요청 메시지를 수신하여 소켓 인터페이스로 HTTP 응답을 전송한다
- 일단 클라이언트가 소켓 인터페이스로 메시지를 보내면 그 메시지는 클라이언트의 손에서 벗어나 TCP의 손안에 있게 된다.
- TCP는 HTTP로의 안정적인 데이터 전송 서비스를 입증함
- 클라이언트 프로세스가 보낸 각각의 HTTP 요청 메시지를 서버에 그대로 도착한다



### HTTP는 상태가 없다

- 서버는 이전 클라이언트 요청에 대해 정보가 없는 채로 유지한다.
- 상태 저장 프로토콜 - "상태"를 유지하는 프로토콜
- - 복잡함
- - 과거 정보가 유지되어야 한다.
  - 서버/클라가 충돌할 경우 "상태"에 대한 시각이 불일치할 수 있으므로, 조정되어야 함



### HTTP 연결

- 클라이언트가 일련의 요청을 만들고 서버가 각 요청에 응답합니다.

1. 각 요청/응답은 별도의 TCP 연결을 통해 전송된다.
2. 모든 요청과 이에 대한 응답은 동일한 TCP 연결을 통해 전송된다.



1. 비영구 HTTP

- TCP 연결을 통해 전송되는 최대 하나의 객체
- 연결 후 닫힌다
- 다중 객체 다운로드 시 다중 TCP 연결 필요

2. 영구 HTTP

- 클라이언트 ,서버 간에 단일 TCP연결을 통해 여러 개체를 전송할 수 있다.





### 비영구 HTTP

- URL 가정 : www.someSchool.edu/someDepartment/home.index

1a. HTTP 클라이언트는 HTTP 서버에 TCP연결을 시작한다.

1b. 포트80번에 TCP연결을 기다리는 호스트는 HTTP 서버. "연결 허용" 클라이언트에게 알린다. TCP 연결과 관련하여 클라이언트에는 소켓이 있고 서버에도 소켓이 있을 것이다

2. HTTP 클라이언트는 소켓을 통해 HTTP 요청 메시지(URL 포함)을 전송한다. 메시지는 클라이언트가 오브젝트 someDepartment/home.index를 원함을 나타낸다

3. HTTP 서버는 요청 메시지를 수신하고, 요청된 개체가 포함된 응답 메시지를 형성하며, 소켓을 통해 응답 메시지를 클라이언트에게 보낸다.
4. HTTP 서버는 TCP연결을 닫기위해 TCP를 호출한다.

5. HTTP 클라이언트는 HTML 파일이 포함된 응답 메시지를 수신하고 HTML을 표시한다, TCP연결은 종료된다. HTML 파일 구문 분석 중, 참조된 10개의 JPG 개체를 찾는다.
6. 단계 1-5를 각 10개의 JPEG에 대해 반복



- HTTP
- - HTTP 사양은 오직 클라이언트와 서버 사이에서 통신 프로토콜로 정의한다.
  - 클라이언트가 웹페이지를 해석하는 방법과는 무관



- 직렬 TCP 연결 vs 병렬 TCP 연결
- - 사용자들은 병럴 처리 정도를 제어하도록 최신 브라우저를 구성할 수 있다.
  - 기본 모드에서 대부분의 브라우저는 5-10개의 병렬 TCP 연결을 연다



### 비영구 HTTP : 응답시간

RTT(Round-Trip time) : 작은 패킷이 클라이언트에서 서버로 이동한 후 돌아오는 시간 : 패킷 전파 지연, 패킷 대기열 지연 및 패킷 처리로 HTTP 응답 시간이 지연된다.

- TCP 연결을 시작하는 RTT 1개
- HTTP 요청을 위한 RTT 1개와 반환할 HTTP 응답의 첫 몇 바이트
- 파일 전송 시간
- 비영구 HTTP 응답 시간 = 2 RTT + 파일 전송시간



비영구 HTTP 결점

- 요청대상별 TCP 연결 신설
- 웹 서버의 OS 오버헤드(TCP 버퍼)
- 각 물체에 2 RTT의 전다 지연 발생



### 영구 HTTP

#### HTTP 1.1 영구 연결

- 서버는 응답 후 TCP 연결을 열어 둔다
- 동일한 개방형 연결을 통해 동일한 클라이언트/서버 간의 후속 HTTP 메시지를 보낸다
- 단일 지속 TCP 연결로 전체 웹페이지 전송 가능
- 동일한 서버에 상주하는 여러 웹 페이지를 단일 영구 TCP 연결을 통해 서버에서 동일한 클라이언트로 전송할 수 있다.
- 보류중인 요청에 대한 응답(파이프라인)을 기다리지 않고 이러한 객체 요청을 연속하여 수행할 수 있다
- 서버는 연속 요청을 받으면 개체를 연속해서 전송한다
- HTTP 기본모드는 파이프라인을 이용한 영구접속 방식이다.



#### HTTP/2 [RFC 7540]

- 여러 요청과 응답을 동일한 연결에 인터리브할 수 있으며, 이 연결내에서 HTTP 메시지 요청과 응답의 우선 순위를 결정하는 메커니즘



### HTTP 요청 메시지

- HTTP 메시지의 두가지 타입 : 요청, 응답
- HTTP 요청 메시지 : ASCII 

![K-054](https://user-images.githubusercontent.com/38898759/137615595-7a440ed2-a82e-48aa-86a7-b10f65899c04.png)



![K-055](https://user-images.githubusercontent.com/38898759/137615607-c686e8fe-d9f9-4ce2-a228-2a945d2edbde.png)



### 업로딩 폼 입력

#### POST method

- 웹 페이지는 종종 입력 폼을 포함한다.
- 개체 바디는 사용자가 폼필드에 입력하는 것을 포함한다.



#### URL method

- GET 메소드 사용
- 입력은 요청라인의 URL 필드에 업로드된다.
- - www.somesite.com/animalsearch?monkeys&banana



### 메소드 타입

#### HTTP/1.0:

- GET
- POST
- HEAD
- - GET과 같다. 하지만 오직 헤드와 상태라인을 전송한다.
  - 디버깅을 위해



#### HTTP/1.1:

- GET, POST, HEAD
- PUT
- - 웹 출판 도구와 연계하여 사용
  - URL 필드에 지정된 특정 웹 서버의 경로에 엔티티 본체의 파일을 업로드한다
- DELETE
- - URL 필드에 명시된 웹 서버에 있는 개체를 삭제한다.



- GET

- - GET 메서드는 지정된 URI를 사용하여 지정된 서버에서 정보를 검색하는 데 사용된다. GET을 사용하는 요청은 데이터만 검색해야 하며 데이터에 다른 영향을 미치지 않아야 한다.

- HEAD

- - GET와 동일하지만, 상태줄, 헤더 부분만 전송된다

- POST

- - 서버에 데이터를 전송하기 위해 사용된다.
  - ex) 고객 정보, 파일업로드

- PUT

- - 대상 자원의 현재 표현을 모두 업로드된 콘텐츠로 대체

  DELETE

  - URI에서 지정된 대상 자원의 현재 표현을 모두 제거한다.

![K-056](https://user-images.githubusercontent.com/38898759/137615792-9c70e3ea-0778-4c52-8afa-94ae900f944d.png)

### HTTP 응답 상태 코드

- 200 OK

- - 요청 성공, 요청된 개체가 메시지로 전송된다.

- 301 Moved Permanently

- - 요청된 개체 이동됨. 새로운 위치가 명시됨

  400 BAD Request

  - 요청 메시지가 서버에서 이해하지 못함

- 404 Not Found

- - 요청된 문서를 찾을 수 없다

- 505 HTTP Version Not Supported





### 사용자-서버 상호작용 : 쿠키

HTTP 서버는 상태가 없다

- 간단하게 디자인
- 고성능 웹서버는 수 천개의 동시 TCP연결을 처리할 수 있다

- 웹 사이트가 사용자를 식별하는 데 종종 바람직함
- 서버, 사용자 접근 제한 희망
- 서버는 사용자 ID의 기능으로 서버 콘텐츠를 사용하고자 함
- 쿠키를 통해 웹사이트의 사용자 추적 가능
- 쿠키 기술은 4가지 요소로 구성되어 있다
- 1. HTTP 응답 메시지의 쿠키 헤더
  2. 다음 HTTP 요청 메시지에서 쿠키 헤더
  3. 사용자의 최종 시스템에 보관된 쿠키 파일, 사용자의 브라우저에서 관리
  4. 웹 사이트의 백엔드 데이터베이스



example:

- 수잔은 항상 PC로 인터넷에 접속한다
- 특정 전자상거래 사이트 아마존에 처음 방문함
- 초기 HTTP 요청이 사이트에 도착하면 사이트는 다음을 생성한다
- - 고유 ID 번호
- ID를 위한 백엔드 데이터베이스 항목



#### 쿠키는 무엇을 위해 사용되나?

- 인증
- 쇼핑 카트
- 추천
- - 과거에 방문한 웹페이지 기반으로 제품을 추천한다
- 사용자 세션 상태



#### 어떻게 상태를 유지하나?

- 쿠키는 상태없는 HTTP의 탑에 사용자 세션 레이어를 만드는데 사용될 수 있다.
- 프로토콜 엔드포인트 : 여러 거래에 대해 발신인/수신인 상태를 유지한다
- 쿠키 : HTTP 메시지 전달 상태



### 웹 캐시(프록시 서버)

- 목표 : 오리진 서버를 사용하지 않고 클라이언트 요청 충족

- 사용자가 브라우저를 구성한다. 캐시를 통한 웹 액세스
- 브라우저는 모든 HTTP 요청을 캐시로 보낸다
- - 캐시에 있는 개체 : 캐시가 개체를 반환한다
- - 그렇지 않으면 오리진 서버에서 요청 개체를 캐시한 다음 다음 클라이언트로 개체 반환

- 캐시가 클라이언트 및 서버 역할을 모두 수행
- 요청 고객용 서버
- 클라이언ㅌ에서 오리진 서버로
- 캐시는 일반적으로 ISP(대학, 회사, 거주 ISP)에 설치한다.



#### 왜 웹 캐싱인가?

- 클라이언트 요청에 대해 응답시간을 줄이기 위해
- 트래픽을 줄이기 위해
- 전체적으로 인터넷의 웹 트래픽을 줄여 모든 애플리케이션의 성능을 개선한다



### 조건부 GET

- 캐시에 있는 개체의 복사본이 오래되었을 수 있다.
- 사본이 캐시된 이후 웹 서버가 수정되었을 수 있음
- 조건부 GET
- - 캐시가 객체가 최신 상태인지 확인한다
  - 1. Get method 2. 수정한 경우 : 헤더라인
- 서버 : 캐시된 개체가 최신인 경우 응답에 오브젝트가 없다






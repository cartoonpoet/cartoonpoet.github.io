---
layout: post
title: 3장 데이터의 표현
subheading: Data representation
author: JunHo
categories: 컴퓨터구조
banner: https://bit.ly/32PAjtM
tags: 컴퓨터구조 computer 디지털논리회로 구조론 컴퓨터 개발 코딩 데이터표현 데이터 표현 2진법 10진법 8진법 16진법
sitemap :
  changefreq : daily
  priority : 1.0



---



## 디지털 컴퓨터는 왜 2진수를 사용하나?

---

- 불연속인 수를 사용하여 계산을 수행한다.
- 하드웨어는 전자기적 소자로 구성됨
- 인간 논리는 참 또느 거짓으로 구분된다.
- 2진수는 컴퓨터가 사용하기에 편리하지만 사람이 사용하기 어려움

-> 사람이 사용하기 편리하도록 다양한 방법을 고안함

예) OS, bios, API, BCD, 3초과 코드, 그레이 코드 등





### 데이터의 종류

---

- 산술 연산에 쓰이는 숫자

- 데이터 처리에 쓰이는 영문자
- 특수 목적에 쓰이는 기호



R진법의 수 -> 10진법의 수

- 수의 크기 계산



10진법의 수 -> R진법의 수

- 진법이 변해도 크기는 변하지 않는다.
- 10진법의 수를 R로 나누어 R진법의 수를 구한다.

![K-004](https://user-images.githubusercontent.com/38898759/114312689-82314500-9b2e-11eb-8bf6-90047bcd7abe.jpg)





### 2진수

---

![K-005](https://user-images.githubusercontent.com/38898759/114312704-8eb59d80-9b2e-11eb-812b-4c60d2efca7c.jpg)

- 사람이 다루기 불편
- 2^3=8:2 진수를 3자리씩 읽으면 8진수
- 2^4=16:2 진수를 4자리씩 읽으면 16진수





### 2진수, 8진수, 16진수의 대응 관계

---

![K-006](C:\Users\carto\Desktop\칼무리\K-006.jpg)



#### 코드

- 유한 개의 원소로 구성된 집합의 원소들에게 서로 구분할 수 있는 유일한 수를 부여한 숫자



#### 숫자 코드

- 10진수에 코드를 부여한 것
- 이진화 십진 코드 (BCD, Binary Coded Decimal)



#### 문자 코드

- 문자를 숫자로 표현한 것
- 아스키 코드, 유니코드



## 3.2 보수

---

#### 보수

- 디지털 컴퓨터에서 뺄셈 연산과 논리 계산에 사용한다.



#### (r-1)'s complements

- N: r진법, n 자리의 수
- N의 (r-1)'s complement=(r^n-1)-N
- - N의 각 자리의 숫자를 (r-1)에서 뺀 것과 동일하다.
  - 예) 10진수 546700의 9의 보수 = 453299
  - 예) 2진수 1011001의 1의 보수 = 0100110
  - - 2진수에서 1의 보수는 1은 0, 0은 1로 바꾼것과 동일



#### r's complements

- N : r진법, n자리 수의 수
- N의 r's complement = r&n - N
- - (r-1)'s complement + 1 과 동일
  - 예) 10진수 546700의 10의 보수는 10^6 - 546700 = 453300
  - 예) 10진수 546700의 9의 보수+1 = 453299 + 1 = 453300
  - 예) 2진수 1011001의 2의 보수 = 2^7 - 1011001 = 0100111



보수의 보수는 원래 수이다.



#### 부호 없는 수자의 뺄셈 연산

- -(minus) 부호가 붙은 수의 r's complement를 취하고 더함

- 예) 8-6=2, 8-6=8+(4) = 12

- A-B의 계산

- - A>B

  - - End carry(끝자리 올림수)가 발생하면 End carry를 무시한 양의 수가 답
    - ex) 1000 - 0110 = 1000 + (1001+1)=10010

    A<B

    - End carry가 없으므로 결과에 다시 r의 보수 취하고 앞에 -부호를 붙여주면 답

    - ex) 6 - 8 = 6+2 = 8 -> -(2)
    - ex) 0110 - 1000 = 0110 + (0111 + 1 ) = 1110 -> -(0001+1)=-0010



### 2진수의 부호 표현

---

- 부호화-크기 표현
- 1의 보수 표현
- 2의 보수 표현



#### 부호화-크기 표현

- 표현한 이진수의 가장 왼쪽 비트가 0이면 양수, 1이면 음수
- +0과 -0은 다르다.



#### 1의 보수 표현

- Signed-1's complement : +0과 -0이 다름, 논리연산 사용



#### 2의 보수 표현

- Signed-2's complement : 산술 연산에 사용



예) -14는 (+14를 8비트로 표현시 00001110)

- 부호화 크기 표현 : 1 0001110
- 1의 보수 표현 : 1 1110001
- 2의 보수 표현 : 1 1110010



![K-007](https://user-images.githubusercontent.com/38898759/114313182-73e42880-9b30-11eb-8b7f-42da5dd7e8ac.jpg)



#### 산술 가산

- 2의 보수로 표현된 수들의 덧셈 방법
- 두 수를 더하고, 만약 올림수가 발생하면 버린다
- 가장 왼쪽 비트가 1인 경우 음수이므로 결과를 다시 2의 보수 취해줌

![K-008](https://user-images.githubusercontent.com/38898759/114313632-28327e80-9b32-11eb-9317-22e6f1eb4c0f.jpg)





#### 산술 감산

- 덧셈을 이용하여 수행한다.
- A : 피감수, B : 감수

![K-009](https://user-images.githubusercontent.com/38898759/114313656-48fad400-9b32-11eb-88a5-da4f821bf02f.jpg)





#### 오버 플로

- 덧셈이나 뺄셈의 결과가  그 범위를 초과하여 결과값이 틀리게 되는 상태

- 검출 방법 : 두 올림수들 간의 exclusive-OR 이용





#### 부동소수점

- 소수점의 위치를 이동시킬 수 있는 수 표현 방법
- 수 표현 범위 확대




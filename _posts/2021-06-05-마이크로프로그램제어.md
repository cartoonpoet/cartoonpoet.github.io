---
layout: post
title: 7장 마이크로 프로그램된 제어
subheading: Microprogrammed Control
author: JunHo
categories: 컴퓨터구조
banner: https://bit.ly/32PAjtM
tags: 기본 컴퓨터 프로그래밍 컴퓨터구조 마이크로프로그램 제어
sitemap :
  changefreq : daily
  priority : 1.0


---



## 7.1 제어 메모리

---



### 제어 장치 수행

- 프로세서의 제어 장치는 기계명령어를 제어 신호로 변환한다.  마이크로 연산을 수행하기 위해
- Hardwired control : 조합 논리 회로 
- ![K-153](https://user-images.githubusercontent.com/38898759/120833091-59608580-c59c-11eb-8403-2c788bf8db9c.png)

- 마이크로 프로그램된 제어
- - 프로세서 위에 있는 제어 메모리는 필수적인 제어 신호를 활성화하는 마이크로 프로그램을 포함한다.



### 마이크로 프로그램된 제어의 주요 이점

- 하드웨어 구성은 변경할 필요가 없다.
- - 만약 우리가 제어를 변경하길 원한다면 -> 오직 마이크로 프로그램만 변경된다.
- 대부분의 RISC 기반 컴퓨터들은 hardwired control를 사용한다.
- - 하드 와이어 : 매크로 명령어를 처리하기 위해 논리 회로를 이용하여 구성한 제어 방식
  - 마이크로 프로그램 방식 : 하나의 기계어 명령어인 매크로 명령어를 수행하기 위해 컴퓨터에서 수행 되어야 하는 여러 가지의 작업들을 처리하도록 지시하는 명령어인 마이크로 명령어들을 프로그램화하는 제어방식



마이크로 프로그램된 제어

- ![K-154](https://user-images.githubusercontent.com/38898759/120834032-73e72e80-c59d-11eb-856f-ae8ad43673f5.png)



### 마이크로 프로그램된 제어 장치

- 메모리에는 컨트롤 워드가 저장된다. 
- 컨트롤 워드 : 마이크로 연산이 필요한 시간이 주어져 있을 때 마이크로 연산에서 사용되는 컨트롤 변수를 저장하고 있는 단어를 말한다.

- ![K-155](https://user-images.githubusercontent.com/38898759/120834215-b01a8f00-c59d-11eb-8d59-13b425941282.png)

- 마이크로 프로그램 : 마이크로 명령어의 연속



### 제어 메모리

- ROM : 데이터가 변경되지 않는다.
- 동적 마이크로 프로그래밍 (RAM) : 마이크로 프로그램 <- 보조 메모리로부터 로드됨
- 컴퓨터는 마이크로 프로그램된 제어 장치로 작동한다. 두가지 종류의 메모리를 사용한다.
- - 메인 메모리 : 프로그램에 의해 변경된 값을 저장한다.
  - 제어 메모리 : 고정된 마이크로 프로그램이 저장됨





### 마이크로 프로그램

- 메모리에 저장된 프로그램이다. 컨트롤 메모리에 저장됨. 어떤 명령어 집합중에 정확한 명령어를 실행시키기 위해 필요한 제어 신호를 발생시키는데 사용된다.
- 마이크로 명령어들로 구성되어 있다.



### 마이크로 명령어

- 컨트롤 워드와 시퀀스 워드로 구성되어 있다.
- - 컨트롤 워드 : 한 클럭 사이클 동안에 필요한 모든 제어 정보를 만들 수 있다.
  - 시퀀싱 워드 : 다음에 실행될 마이크로 명령어의 주소를 결정하는데 필요한 정보를 가지고 있다.
- 마이크로 프로그램을 쓴다.



### 컨트롤 메모리 (CS)

- 저장장치이다. 마이크로 프로그램된 제어장치에 포함되는 그러한 저장소이다. 그런 공간이 하는 일은 마이크로 프로그램을 저장하는데 사용된다.



### 쓰기 가능한 제어 메모리 (WCS)

- CS에 저장된 마이크로 프로그램에 저장된 내용을 변경할 수 있어야 한다.
- - 마이크로 프로그램을 변경할 수 있다.
  - 명령어 집합을 변경하거나 수정할 수 있다.



### 동적 마이크로 프로그래밍

- 쓰기 가능한 제어 메모리(WCS)에 마이크로 프로그램이 구현되어 있는 제어장치를 가진 컴퓨터 시스템
- 이 장치에 있는 마이크로 프로그램은 시스템 프로그래머에 의해서 또는 사용자에 의해서 변경이 가능하다.



### 다음 주소 생성기(sequencer)

- 최소 시작, 증가, 로드 제어 주소 레지스터쪽으로 , 외부 주소로부터
- 처음에 시작하는 주소로 데이터들이 증가시키는 형태로 동작하기도 하고, 또는 컨트롤 주소 레지스터에 저장되어 있는 값으로 부터 전달받은 주소가 저장되기도 한다. 다른 외부로부터 특정 주소값이 저장되기도 한다.



### 제어 데이터 레지스터 (CDR)

- CDR(pipline register) 은 다음에 실행할 명령어의 주소가 계산되고 또는 메모리로부터 읽어오는 동안에 동시에 현재 실행되고 있는 마이크로 연산을 같이 가지고 있을 수 있다.
- - 마이크로 연산과 다음 실행될 마이크로 명령어를 생성하는 것을 동시에 할 수 있기 때문에
  - 동시에 하려면 두개의 클럭이 필요하고, 하나의 클럭은 CAR, 다른 클럭은 CDR로 사용된다.
  - ![K-156](https://user-images.githubusercontent.com/38898759/120835428-48654380-c59f-11eb-834c-4dcd9bef245b.png)



### 어드레스 시퀀싱

- 다음에 실행할 주소를 만들어내는 과정
- 시퀀서가 어드레스 시퀀싱에 의해서 어떻게 주소를 만들어내는지..
- 클럭이 하나밖에 없기 때문에 컨트롤 데이터 레지스터가 두개의 클럭을 이용해서 동시에 동작하는 형태의 동작을 수행할 수가 없다. 컨트롤 데이터 레지스터가 없다고 생각하자.
- 컨트롤 워드와 다음 주소 정보가 직접적으로 컨트롤 메모리로부터 출력된다고 생각하고 설계한다.
- - 롬은 조합회로처럼 작동한다. 입력값 : 주소, 출력값 : 제어 워드
  - 롬에 있는 특정한 내용이 계속해서 유지되고 있다. CAR에 있는 어떤 주소값이 남아있는 동안에는 계속해서 출력되고 있는 값이 남아있다.



### 마이크로 프로그램 시퀀서

- 다음 클럭 사이클 동안에 실행될 마이크로 명령어 주소를 결정하는 마이크로 프로그램 제어장치다.
- - In-line sequencing
  - branch
  - 조건부 분기분
  - 서브루틴
  - 루프
  - 명령어 opcode 맵핑과정





## 7.2 주소 시퀀싱

---

- 명령어는 여러 마이크로 명령어들의 집합이다.





### 마이크로 프로그램 루틴 실행 단계

- fetch routine : 최초 주소로 시작 -> 명령어는 IR에 있다.
- 유효 주소 루틴 : MAR <- 오퍼랜드의 주소
- ![K-157](C:\Users\carto\Desktop\칼무리\K-157.png)
- 실행 후 fetch 루틴으로 반환한다.



### 제어 저장소에 필요한 시퀀싱 기능

1. 제어 주소 레지스터 증가
2. 무조건적이고 조건부적인 분기
3. 기계 지침의 비트에서 제어 메모리를 위한 주소로 매핑하는 프로세스
4. 서브루틴 콜 및 리턴 시설



### 제어 메모리를 위한 다음 마이크로 명령어 주소 선택

![K-158](https://user-images.githubusercontent.com/38898759/120839397-db07e180-c5a3-11eb-9a01-f18aca49e0a5.png)

- 위 사진은 제어 메모리와 다음 명령어를 선택하는 데 필요한 하드웨어를 나타낸 블럭도이다.
- 제어 메모리의 마이크로 명령어에는 컴퓨터 레지스터에서 마이크로 연산을 시작하게 하는 비트들과 다음 주소를 얻는 방법을 지시하는 비트들이 포함되어 있다.
- 위 그림에서는 제어 주소 레지스터(CAR)에 주소가 입력되는 네 가지 방법을 보여주고 있다.
- - 인크리멘터는 제어 주소 레지스터의 값을 하나 증가시켜 순차적인 수행이 이루어지도록 하고, 분기는 마이크로 명령어의 한 필드에서 지정된 분기 주소에 의해 이루어진다.
  - 조건부 분기는 마이크로 명령어의 일부분을 참조하여 분기조건을 결정하기 위한 상태 비트를 선택한다.
  - 외부 주소는 매핑 논리 회로를 통하여 제어 메모리로 전송되며, 서브루틴의 복귀 주소는 특별한 레지스터에 저장된다.



### 조건부 분기

- 분기 논리(branch logic)에서는 상태 비트가 가지는 정보에 따라서 선택적인 분기동작을 하게 되어 제어 장치는 판단 능력을 가지게 된다.
- 분기 논리의 하드웨어는 다양한 방법으로 설계될 수 있는데, 가장 간단한 방법은 특정 상태를 테스트하고 조건에 맞다면 주어진 주소로 분기하며, 그렇지 않다면 바로 다음의 마이크로 명령어를 수행하도록 하는 것이다.
- 멀티플렉서를 이용하여 설계할 수있다. 여덟 개의 상태 비트가 있다고 가정하고 마이크로 명령어 중 3비트가 이 여덟 개의 상태 비트 중 하나를 선택하게 한다. 선택된 상태 비트가 1이면 멀티플렉서 출력이 1이 되어 지정된 주소를 제어 주소 레지스터에 로드하게 되고, 0이면 멀티플렉서 출력이 0이 되어 제어 주소 레지스터는 증가하게 된다.  이 경우 마이크로 프로그램은 상태 비트의 값에 따라 둘 중 하나의 경로를 따라 진행한다.
- 무조건 분기 명령어를 제어 메모리로부터 분기 주소를 적재함으로써 구현되는데, 상태 비트 중 하나를 항상 1로 고정시키고 이 비트를 선택하게 함으로써 가능할 수 있다.



### 명령어의 매핑

- 어떤 매크로 연산을 수행하는 제어 메모리의 루틴으로 분기하는 경우를 생각해 보자. 이때, 분기하는 주소를 결정하기 위해서 명령어 OP-코드 부분이 사용된다.
- 예를 들어 4비트의 OP-코드를 가진 명령어가 있고, 또 워드의 제어 메모리가 있다고 가정하자. 각 매크로 연산을 위한 루틴으로 분기하려면 7개의 주소를 나타내는 비트가 필요하다. 4비트의 OP-코드를 7비트의 주소로 배핑하는 작업이 필요하다.
- 가장 오른쪽 2비트와 가장 왼쪽 1비트를 0으로 하여 7비트를 만들었는데 한 개의 매크로 연산은 네 개의 마이크로 명령어를 가질 수 있게 된다.루틴이 네 개 이상의 마이크로 명령어를 필요로 하면 1000000에서 1111111까지의 주소를 이용할 수 있다.
- 메모리 매핑은 PLD라 불리는 집적 회로 방식으로 흔히 실현된다. PLD는 디코더 대신에 내부적으로 AND와 OR 게이트를 사용하는 것을 제외하면 개념적으로 ROM과 비슷하다.



### 서브루틴

- 흔히 많은 마이크로 프로그램이 동일한 코드의 모임을 갖게 되는데 이 부분을 서브루틴화함으로써 제어 메모리를 절약할 수 있다.
- 예를 들어 피연산자의 유효 주소를 계산하는 것은 메모리 참조 명령어 모두가 가지는 것이므로 서브루틴으로 만드는것이 편리하다.
- 리턴 주소는 특수한 레지스터에 미리 기억시켜두고 서브루틴으로 분기해야 다시 루틴으로 돌아올 수 있다.





## 7.3 마이크로 프로그램의 예

![K-159](https://user-images.githubusercontent.com/38898759/120883843-7fc50600-c61a-11eb-8af3-222dc5535ac9.png)



### 컴퓨터 구성

- 위 그림에서 블럭도로 나타낸 컴퓨터는 명령어와 데이터를 저장하기 위한 주 메모리와 마이크로 명령어를 저장하기 위한 제어 메모리를 가지고 있다. 프로세서 레지스터로 프로그램 카운터(PC), 주소 레지스터(AR), 데이터 레지스터(DR), 누산기 레지스터(AC)를 가지고 있고, 제어 장치에는 제어 메모리와 함께 마이크로 프로그램된 제어 장치를 구성하기 위한 제어 주소  레지스터(CAR)와 서브루틴 레지스터(SBR)가 있다.
- 프로세서에서의 레지스터들 간의 정보 전송은 공통 버스보다는 멀티플렉서를 통해서 이루어진다. 위 그림에서 DR은 AC, PC 및 메모리에서 데이터를 받을 수 있고, AR은 PC와 DR에서 받을 수 있으며, PC는 AR로부터만 정보를 받을 수 있다. 산술 논리 시프트 장치는 AC와 DR에 있는 데이터에 대해 마이크로 연산을 수행하여 그 결과를 AC에 저장하며, 메모리는 DR 하고만 데이터를 주고받을 수 있다.

- ![K-161](https://user-images.githubusercontent.com/38898759/120884359-c5370280-c61d-11eb-8491-973f54c2a70b.png)
- - 위 그림 7-5(a)에 컴퓨터 명령어의 형식을 나타내고 있는데, 간접 주소를 표시하는 I, 4비트의 연산 코드(opcode), 11비트의 주소 등의 세 필드로 구성되어 있다. 
  - 그림 7-5(b)는 16메모리 참조 명령어 중에서 네 개를 보여주고 있다. ADD 명령어는 유효 주소에 저장되어 있는 피연산자를 AC의 값에 더하는 동작을 하고, BRANCH 명령어는 AC에 있는 피연산자가 음수일 때 유효 주소로 분기하는 동작을 한다. STORE 명령어는 AC의 값을 유효 주소로 지정된 메모리에 저장하는 동작을 수행하며, EXCHANGE 명령어는 AC의 데이터와 유효 주소로 지정된 메모리의 데이터를 서로 교환하는 동작을 한다.





### 마이크로 명령어 형식

- ![K-162](https://user-images.githubusercontent.com/38898759/120884362-c5cf9900-c61d-11eb-8679-8a13bdaa7407.png)
- 20비트로 4개의 필드로 나뉘어 있다. F1, F2, F3로 표시되는 필드는 컴퓨터의 마이크로 연산을 지정하고, CD 필드는 상태 비트 조건을 선택한다. BR 필드는 분기의 종류를 지ㅏ정하고, AD 필드는 분기 주소를 가지고 있다. 주소 필드는 7비트 이므로 제어 메모리의 크기가 128 = 2^7임을 알 수 있다.
- 마이크로 연산을 지정하는 세 개의 필드는 새 비트로 구성되어 각각 서로 다른 일곱가지 동작으로 해석된다. 그러므로 모두 21개의 마이크로 연산을 표시할 수는 있지만, 하나의 마이크로 명령어에는 세 개의 동작만 지정할 수 있다. 세 개 동작을 모두 사용하지 않을 때에는 해당 필드의 값을 이진수 000으로 지정해준다. 
- - 예를 들어 F1, F2, F3에 000 100 101의 값을 줌으로써 다음과 같이 두 개의 마이크로 연산을 동시에 지정할 수 있다. DR <- M[AR] (F2 = 100), PC <- PC+1 (F3 = 101)
- 그러나 마이크로 연산 필드에 010 001 000과 같은 값을 지정하면 AC를 0으로 클리어하는 동작과 AC에서 DR을 빼는 동작을 동시에 수행하여 충돌이 발생한다. 따라서 이와 같은 충돌이 발생하는 동작은 동시에 지정할 수 없다.
- 전송을 나타내는 마이크로 연산은 근원 레지스터와 목적 레지스터를 포함하도록 다섯 개의 문자로 표시된다. 예를 들어 DR에서 AC로 전송하느 동작은 DRTAC로 표시한다. (DR to AC?)
- CD 필드는 상태 비트 중 하나를 지정한다. 처음 조건은 항상 값이 1인 것으로, CD=00일 때 항상 참인 조건을 나타낸다. 이 조건은 BR 필드와 함께 사용되어 무조건 분기 동작을 하게 된다.
- 간접 비트 I는 DR의 15번째 비트에, S는 AC의 부호 비트에 따라 그 값이 정해지는 상태 비트이고, Z는 AC가 0일 때 참이 되는 상태 비트이다. BR 필드는 2비트로 구성된다. 주소 필드 AD와 연관되어 쓰일 때 다음 마이크로 명령어의 주소를 선택하게 된다.
- BR=00이면 점프 동작을 하고, BR=01이면 서브루틴 CALL 동작을 한다. JMP와 CALL은 CD필드의 영향을 받는다. CD 필드에서 선택된 조건이 1이면 AD에 있는 주소로 분기되며, 0이면 바로 다음 명령을 실행한다.
- 서브루틴으로부터의 복귀는 SBR의 값이 CAR로 옮겨지는 것으로 BR=10일 때이다. BR=11이면 매크로 연산 비트로부터 CAR로의 매핑은 7-3과 같다. 매크로 연산은 명령어의 OP-코드 부분을 말하는 것인데, DR(11 - 14)로써 나타낸다. BR 필드의 마지막 두 조건은  CD와 AD 필드의 값과 무관함에 유의하자.



### 기호로 표시된 마이크로 명령어

![K-164](https://user-images.githubusercontent.com/38898759/120886149-768e6600-c627-11eb-8e2f-2289af4bdf08.png)
![K-165](https://user-images.githubusercontent.com/38898759/120886150-77bf9300-c627-11eb-8137-b57a04149e9f.png)

- 위 사진에서 정의된 기호는 마이크로 명령어를 기호 형태로 나타내는데 사용된다. 기호로 표시된 마이크로 프로그램은 어셈블러를 통하여 이진 코드로 바꿀 수 있다.
- 각 기호로 된 마이크로 명령어는 라벨, 마이크로 연산, CD, BR, AD 등 다섯 개의  필드로 나뉘어 있는데 각 필드는 다음의 정보를 갖게 된다.

1. 라벨 필드는 공백일 수도, 기호 주소를 나타낼 수도 있다. 라벨 뒤에는 콜론(:)이 붙어야 한다.
2. 마이크로 연ㅅ나 필드는 표7-1에서 정의된 한 개나 두 개 또는 세 개의 기호로 구성되고, 각 기호는 콤마(,)로 분리된다.
3. CD 필드는 U, I, S, Z 중 하나의 문자를 갖는다.
4. BR 필드는 표 7-1에 정의된 네 개의 기호들 중 하나를 갖는다.
5. AD 필드는 다음  세 가지 기호 중 하나를 가지는데, 이는 다음 주소를 결정하는 방법을 나타낸다.

- a. 기호 주소(이는 라벨로 프로그램 상에 나타나야 한다.)
- b. NEXT(이는 연속된 다음 주소를 뜻한다)
- c. BR이 RET이나 MAP이면 AD는 공란으로 둔다.

또한 ORG라는 슈도 명령어를 사용하는데, 이는 마이크로 프로그램 루틴의 처음 시작하는 위치를 나타낸다. 즉, ORG 64는 제어 메모리의 64번지에 다음 마이크로 명령어를 기억시키라는 뜻이다.



### FETCH 루틴

- 제어 워드는 128워드르 가지고 있으며, 각각의 워드는 20비트로 이루어진다. 0~63번지는 16개의 매크로 연산을 위한 루틴으로 사용하고 64-127번지는 다른 용도로 사용한다. fetch 사이클 루틴을 시작하는 첫 번쨰 위치를 64번지라 한다. fetch 루틴에 필요한 마이크로 명령어는 다음과 같다.
- AR ← PC
- DR ← M[AR], PC←PC+1
- AR←DR(0-10), CAR(2-5) ← DR(11-14), CAR(0, 1, 6) ← 0

- 명령어의 주소가 PC에서 AR로 전송되고, 명령어는 메모리에서 DR로 읽혀진다, 명령어 레지스터를 사용하지 않으므로 명령어 코드는 DR에 저장되어 있고, 주소 부분은 AR로 전송된다. DR에 있는 명령어의 연산 코드 부분을 CAR에 매핑시킴으로써 16루틴 중의 하나로 제어를 옮기게 된다.
- ![K-166](https://user-images.githubusercontent.com/38898759/120886432-d9343180-c628-11eb-84fc-1c8cd55bd114.png)



### 기호로 표시된 마이크로 프로그램

- fetch 사이클의 마지막 도작은 fetch된 매크로 연산의 루틴으로의 분기 동작이다. OP-코드가 0000인 ADD 명령어라면 CAR에 0000000을 갖다 놓게 되어 ADD 루틴을 수행하게 한다. 그와 동일한 방법으로 BRANCH는 0000100가, STORE는 0001000가 그 루틴의 시작 위치가 된다. 또한 각 루틴은 네 개의 마이크로 명령어를 가질 수 있다.
- - 각 루틴에서는 유효 주소를 계산하는 동작이 공통적으로 필요하므로 이것을 서브루틴화하면 제어 메모리를 효율적으로 사용할 수있다. 이 서브루틴을 INDRCT 서브루틴이라 부르고 fetch 루틴 다음에 저장하기로 한다.
- ADD 명령을 fetch 한경우를 생각 해보자. fetch 사이클의 맨 끝에 있는 매핑 동작에 의해 ADD 루틴으로 분기되고, 이의 첫 번째 마이크로 명령에서 I=1이라면 간접 서브루틴을 호출하게 하게한다., 이 때 리턴 주소는 SBR에 기억된다.
- ![K-167](https://user-images.githubusercontent.com/38898759/120886481-287a6200-c629-11eb-863a-4f4d3ef24806.png)



- ADD 명령어는 메모리에서 DR 를 통해 피연산자를 읽고 이를 AC와 더하게 된다. 또한 이 도작의 진행이 끝난 후에 fetch 루틴의 처음으로 점프한다.
- BRANCH 명령어는 AC가 음수일 때만 유효주소로 분기하게 한다. AC가 음수가 되면,  이때 상태 비트가 S가 1이 되어 이 상태를 알 수 있게 된다. 위 표의 분기 루틴은 S의 값을 조사하는 것부터 하는데 S=0이면 PC의 값을 변경시키지 않아 분기가 일어나지 않게 되고, 다음 마이크로 명령어는 fetch 루틴으로 분기하게 한다.
- S=1이면 JMP 마이크로 명령어는 OVER의 위치로 분기하게 하고, 이 위치에서 I=1이면 간접 서브루틴을 호출한다. 
- STORE 루틴에서도 I=1이면 간접 서브루틴을 호출한다. AC의 내용이 DR로 전송되고 DR의 내용이 유효 주소에 저장되게 한다.
- EXCHANGE 루틴에서는 유효 주소로부터 DR로 피연산자를 읽어본 다음, 모서리-트리거형 레지스터의 성질을 이용하여 세 번째 마이크로 명령어에서 AC와 DR의 값이 교환된다. DR에 저장된 원래 AC의 값은 메모리로 다시 저장된다.



### 이진 마이크로 프로그램

- 기호로 된 마이크로 프로그램은 읽거나 이해하기에 쉽게 쓰여 있지만, 실제 메모리에 저장되는 형태가 아니다. 따라서 이는 어셈블러나, 또는 사람이 직접 이진 코드로 바꾸어야 한다.
- ![K-168](https://user-images.githubusercontent.com/38898759/120886928-4f399800-c62b-11eb-9632-ded330cd2304.png)
- 위 사진은 이전 사진의 마이크로 프로그램을 이진 코드화 한 것이다. 
- 3번지의 코드는 기호로 된 마이크로 프로그램에는 없는 것이다.  이는 사용되지 않는것이기 때문에 모든 코드를 0으로 했지만 CAR이 만일의 경우 잡음 때문에 3이 될 때를 대비하여 fetch 루틴을 ㅗ점프하게 해두었다.
- 위 표에 열거된 마이크로 프로그램은 제어 메모리의 내용이다. 즉 제어 메모리로 ROM을 이요한다면 이 ROM을 제조하기 위한 진리표로 사용된다. 컴퓨터의 명령어 집합을 변경하려면 그에 따른 새로운 마이크로 프로그램을 저장하는 ROM을 그 이전의 것과 바꾸면 된다.
- RAM을 제저 메모리로 사용한다면, 하드웨어적인 과정없이도 새로운 마이크로 프로그램을 제어 메모리에 기억시킬 수 있다.이러한 동작으로 명령어 집합을 변경시킬 수 있는 융통성에도 불구하고, 대부분의 컴퓨터들은 가격과 속도면에서 우수한 ROM을 사용한다.





## 7.4 제어 장치의 설계

- 마이크로 명령어는 각각 독립된 기능을 가지는 여러 개의 필드로 구성되어 있다. 각 필드는 마이크로 연산을 구동시키기 위한 제어 비트를 포함하거나, 다음 실행될 마이크로 명령어의 주소를 결정하는 방법을 지시하거나 분기를 위한 주소를 포함하고 있다. 동시에 수행되는 마이크로 연산들은 함께 모아서 인코딩하여 나타낼 수 있기 때문에 제어 비트의 수를 줄일 수 있다. 즉 한 필드가 k비트라면 이 필드는 디코더를 통하여 2^k개의 마이크로 연산을 표현할 수 있는 것이다. 



### 마이크로 프로그램 시퀀서

![K-169](https://user-images.githubusercontent.com/38898759/120887273-c9b6e780-c62c-11eb-98d8-2a6404e7d8ba.png)

- 마이크로 프로그램된 제어 장치의 기본 요소는 제어 메모리와 다음 주소를 결정하는 데 사용되는 회로이다. 이때 주소를 결정하는 부분을 마이크로 프로그램 시퀀서라 부른다.
- 다음 주소를 결정하는 용인은 현재 진행중인 마이크로 명령어의 주소비트와 상태 비트이다. 또 장치 내에 레지스터 스택이 있어 마이크로 연산의 루프나 서브루틴 호출할 때의 일싲거인 주소를 저장하기도 한다.
- 다음 마이크로 명령어 주소 로직
- - ![K-170](https://user-images.githubusercontent.com/38898759/120887496-341c5780-c62e-11eb-8aa9-ee64715cb5f4.png)
- - MUX 1은 4개의 출발지와 경로들 중 하나의 주소를 선택한다.
  - In-Line Sequencing → CAR + 1
  - Branch, Subroutine Call → CS(AD)
  - Return from Subroutine → Output of SBR
  - New Machine instruction → MAP
- ![K-172](https://user-images.githubusercontent.com/38898759/120887538-6fb72180-c62e-11eb-85d5-039ab4964bd9.png)
- ![K-173](https://user-images.githubusercontent.com/38898759/120887546-7cd41080-c62e-11eb-975d-45e8ad240225.png)
- 위 그림에서 두 개의 멀티플렉서가 있ㄴ느데 하나는 네 개의 주소 소스 중 하나를 골라 CAR로 보내는 것이고, 나머지 하나는 상태 비트를 선택하여 그 값을 입력 논리 회로의 입력으로 보내게 하는 것이다. CAR의 출력은 제어 메모리의 주소를 나타낸다. CAR+1의 값은 멀티플렉서 입력의 하나가 되기도 하고, SBR에 전송되기도 한다. 멀티플렉서의 다른 세 개의 입력은 각각 현재 진행중인 마이크로 명령의 주소 필드, SBR의 출력, 매크로 연산을 위한 외부의 입력이 된다.
- 다이어 그램에서는 하나의 서브루틴 레지스터(SBR)가 있지만 실제는 레지스터 스택을 가진다. 여러 개의 서브 루틴 호출이 중복되어 사용할 수 있게 한다.
- 즉 이 회로는 세 개의 AND 게이트와 하나의 OR 게이트, 하나의 인버터로 구성할 수 있다. 그림 7-8에서 인크리멘트 회로는 플립플롭을 사용한 것이 아니라 조합회로 이어야 한다. 이는 그림 4-8의 반가산기 회로를 종속 접속하게 하여 설계할 수 있다. 한 스테이지의 출력 캐리는 다음 스테이지의 입력 캐리가 되어야 한다. 가장 처음 스테이지의 입력 캐리는 1로 고정되어야 1이 증가되는 동작을 할 수 있다.


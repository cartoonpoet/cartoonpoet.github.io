---
layout: post
title: 아키텍처
subheading: Architectures
author: JunHo
categories: 분산처리
banner: https://bit.ly/32PAjtM
tags: 분산 시스템 네트워크 System distributed issues 정의 시스템 모델 D Placement Architectures
sitemap :
  changefreq : daily
  priority : 1.0









---



## 아키텍처

---

- 주로 하드웨어는 있다고 치고 이 분산 시스템을 구성하는 소프트웨어 컴포넌트들을 어떻게 구성해야할지에 대한 문제이다. 설계하려는 시스템의 소프트웨어가 어떤 구조를 가질지 설계하고 실제 설계한 내용을 개발해서 구체화하면그게 시스템 아키텍처이다.
- 분산 시스템의 조직을 보는 방법에는 여러가지 방법이 있다.
- - 소프트웨어 구성 요소 모음의 논리적 구성과 실제 물리적 구현 간의 구별
  - 소프트웨어 아키텍처
  - - 상호 작용 방법
  - - 분배 투명성 달성 목표
  - - 사용자에게 배포의 내부 세부 사항을 숨김
  - 시스템 아키텍처
  - - 소프트웨어 구성 요소를 인스턴스화하고 실제 컴퓨터에 배치





## 소프트웨어 아키텍처 스타일

---

- 컴포넌트 
- - 인터페이스를 존중하는 경우 환경 내에서 교체 가능한 정의된 필수 인터페이스와 제공된 인터페이스를 갖춘 모듈형 장치
- 구성요소 상호 연결 방식
- - 구성 요소 간의 통신, 조정 또는 협력을 중재하는 메커니즘
  - RPC, 메시지 전달 또는 스트리밍 데이터를 위한 기능으로 형성됨
- 구성요소 간에 교환되는 데이터
- 구성
- - 이러한 요소를 시스템으로 공동으로 구성하는 방법



다양한 구성

1. Layered architectures
2. Object-based architectures
3. Data-centered architectures
4. Event-based architectures



연구자들은 단일 분산 시스템을 사용하여 가능한 모든 경우의 90%를 처리할 수 있다는 생각을 포기했다.



1. 레이어드 아키텍처

- 구성요소는 레이어드 방식으로 구성됨
- 계층 Li의 구성요소는 기초 계층 Li-1의 구성요소들을 호출할 수 있지만, 그 반대는 아니다.
- 이 모델은 네트워킹 커뮤니티에 의해 채택됨

![K-014](https://user-images.githubusercontent.com/38898759/136828555-8b2ff774-4a9b-47da-91b0-6452ef214cc2.png)



2. 객체 기반 아키텍처

- 각 객체는 구성 요소에 해당된다
- 이러한 구성 요소는 원격 프로시저 호출 메커니즘을 통해 연결된다.
- 이 아키텍처는 클라이언트-서버 시스템 아키텍처와 일치하다.

![K-015](https://user-images.githubusercontent.com/38898759/136828688-fec45293-4878-4c74-acdd-1f743ba461ec.png)

3. 데이터 중심 아키텍처

- 공통 수동 또는 능동 저장소를 통해 통신하는 프로세스
- 공유 분산 파일 시스템
- 웹 기반 분산 시스템
- - 데이터 중심
- - 공융 웹 기반 데이터 서비스를 사용하여 통신하는 프로세스



4. 이벤트 기반 아키텍처

- 선택적으로 데이터를 전달하는 이벤트 전파를 통해 통신하는 프로세스
- 발행/구독 시스템
- 미들웨어가 이벤트를 게시한 후 해당 이벤트에 가입한 프로세스만 이벤트를 수신하도록 보장하는 프로세스
- 프로세스가 느슨하게 결합되어 있다. 그들은 서로 명시적으로 언급할 필요가 없다.
- 공간에서의 분리 또는 참조상 분리

![K-016](https://user-images.githubusercontent.com/38898759/136828937-ae97eba4-c354-47c0-ab01-a1d752acd9b9.png)



### 공유 데이터 공간 아키텍처 스타일

- 데이터 중심 아키텍처와 결합된 이벤트 기반 아키텍처
- 프로세스도 시간에 따라 분리됨
- 통신이 이루어질 때 둘다 활성화될 필요 없다
- 공유저장소에 SQL과 유사한 인터페이스 사용

![K-017](https://user-images.githubusercontent.com/38898759/136829082-c04c5cd5-7f28-4351-9eff-5edea7c3f110.png)



소프트웨어 아키텍처의 다양한 인스턴스화(배치)(CnD의 역할 및 책임):

1. 중앙집중식 아키텍처

- 클라이언트 서버 아키텍처

2. 분산형 아키텍처

- Peer to Peer 아키텍처

3. 하이브리드 아키텍처





### 중앙집중식 아키텍처(클라이언트-서버 아키텍처)

- 서버는 특정 서비스를 구현하는 프로세스다
- 클라이언트는 서버에 서비스를 요청하는 프로세스다
- 요청을 보낸 후 서버의 응답을 기다리는 방법





- 클라이언트와 서버간의 통신은 다음과 같이 수행될 수 있다.

- 1) A connectionless protocol

  - 기반 네트워크가 상당히 신뢰할 수 있는 경우
  - 효율적
  - 프로토콜이 가끔 발생하는 전송 장애에 대해 내성을 갖도록 하는 것은 사소한게 아니다.
  - - 손해가 없이 여러번 반복할 수 있는 동작은 무의미

- 2. A reliable connection-oriented protocol

  - 상대적으로 낮은 성능
  - 통신을 신뢰할 수 없는 광역 시스템에서 잘 작동한다.





- 애플리케이션 계층
- - 클라이언트와 서버를 명확히 구분하는 방법
  - 서버가 클라이언트 역할을 할 수 있다
  - 많은 클라이언트-서버 애플리케이션은 데이터베이스에 대한 사용자 액세스를 지원하는 것을 목표로 하고 있으며, 많은 사람들은 다음의 세 가지 수준 사이의 차이를 지지해왔다.
- 1) 사용자 인터페이스(프레젠테이션) 수준
  2) 처리(비즈니스 로직, 애플리케이션 처리) 수준
  3) 데이터(데이터 액세스, 데이터 지속성) 수준

1) 사용자 인터페이스(표현) 레벨

- 디스플레이 관리와 같이 사용자와 직접 인터페이스하는 데 필요한 모든 것을 포함한다.
- 사용자와의 상호 작용을 처리하는 부품

2. 처리(비즈니스 로직, 응용 처리) 레벨

- 일반적으로 응용프로그램 포함
- 일반적으로 애플리케이션의 핵심 기능을 포함하는 중간 부분
- 사용자 인터페이스 및 데이터 수준과 대조적으로 처리 레벨에 공통적인 측면이 많지 않다

3. 데이터(데이터 접근, 데이터 지속) 레벨

- 실행중인 실제 데이터 관리
- 데이터베이스에서 작동하는 부품
- 데이터는 종종 영구적이다. 즉, 애플리케이션이 실행 중이 아니더라도 다음 사용을 위해 어딘가에 데이터가 저장된다.
- 여러 애플리케이션에 걸쳐 일관된 데이터 관리
- 데이터는 데이터 조직의 변화가 애플리케이션에 영향을 미치지 않고, 애플리케이션도 데이터 조직에 영향을 미치지 않는 방식으로 애플리케이션과 독립적으로 구성된다.

![K-018](https://user-images.githubusercontent.com/38898759/136898716-45310b47-f9b3-4616-a5bc-dc8c1f678be1.png)





다중 계층 아키텍처

- 세가지 논리적 레벨로 구분되는 것은 클라이언트-서버 애플리케이션을 여러 컴퓨터에 물리적으로 분산시킬 수 있는 여러 가능성을 시사한다.
- (물리적으로) 2계층 아키텍처
- 클라이언트 시스템과 서버 시스템 두 종류만 사용
- (물리적으로) 삼층 건축

- 서버가 때때로 클라이언트 역할을 해야 할 수 있다.



2계층 아키텍처

![K-019](https://user-images.githubusercontent.com/38898759/136898889-9d8e10b0-849d-4248-b19c-545bb8948815.png)



a. 클라이언트 컴퓨터에서 사용자 인터페이스의 터미널 의존적인 부분만 - dumb terminal

b. 애플리케이션을 그래픽 프론트 엔드로 분할하여 애플리케이션별 프로토콜을 통해 애플리케이션의 나머지 부분과 통신

c. 응용 프로그램의 일부를 프론트 엔드로 이동한다. 응용 프로그램은 처리되기 전에 완전히 작성해야 하는 양식을 사용한다.

d. 대부분의 응용프로그램이 클라이언트 시스템에서 실행 중이지만 데이터베이스 항목에 대한 작업은 서버로 이동된다.

e. 클라이언트의 로컬 디스크에 데이터의 일부가 포함되어 있다.

- Fat Clients : (d)-(e)

- - 시스템 관리 관점에서 최적 상태가 아니다
  - 복잡한 어플리케이션을 구동할 수 있는 하드웨어와 운영체제를 갖춘 클라이언트 환경
- Thin Clients : (a) - (c)
- - 훨씬 쉬워짐
  - 예전 메인 프레임 시절 CPU 없이 스크린과 키보드만 있는 단말기에 상대적으로 저렴한 하드웨어와 가벼운 운영체제 환경을 갖춘 클라이언트





- 3계층 아키텍처
- - 처리 수준의 일부를 구성하는 프로그램이 별도의 서버에 상주함
  - 많은 웹사이트 구성 "웹 서버는 사이트의 진입점 역할을 하며 실제 처리가 이루어지는 애플리케이션 서버에 요청을 전달한다. 또한 이 응용프로그램 서버는 데이터베이스 서버와 상호작용 한다."





### 분산형 아키텍처 (P2P 아키텍처)

- 수직 분포

- 서로 다른 컴퓨터에 논리적으로 다른 구성 요소 배치

- 여러 대의 컴퓨터에 걸쳐 논리적으로 물리적으로 분할된 기능

- 수평 분포

- 클라이언트 또는 서버는 물리적으로 논리적으로 동등한 부분으로 분할될 수 있지만, 각 부분은 전체 데이터 세트의 자체적인 몫으로 작동하므로 작업량이 동등하다.

- 프로세스는 모두 동일

- 프로세스 간 상호작용의 대부분은 대칭이다. 각 프로세스는 클라이언트와 서버 역할을 동시에 수행

- 오버레이 네트워크에서 프로세스를 구성하는 방법

- - 노드는 프로세스에 의해 형성되며 링크는 가능한 통신 채널을 나타낸다.

  1) 구조화된 P2P 아키텍처 : 분산 해시 테이블(DHT)
  2) 비정형 P2P 아키텍처

#### 1) 구조화된 Peer to peer 아키텍처

![K-020](https://user-images.githubusercontent.com/38898759/136901772-c6485003-1286-40e5-a72a-978e26858fa5.png)

#### 2) 비구조화된 Peer to peer 아키텍처

![K-021](https://user-images.githubusercontent.com/38898759/136901891-c46887ec-ec9b-4007-b932-e994de1ffbb2.png)



#### 3) 하이브리드 아키텍처

- 분산형 아키텍처와 결합된 클라이언트-서버 아키텍처
- 엣지 서버 시스템
- - 서버가 네트워크 가장 자리에 배치되는 인터넷에 배치됨
- - 엣지 서버는 필터링 기능을 적용한 후 콘텐츠를 제공한다
  - 컨텐츠 및 애플리케이션 배포를 최적화하기 위해 서버 모음 사용가능
- ![K-022](https://user-images.githubusercontent.com/38898759/136902576-7d2ac92c-8c79-495d-a563-23170f2c4ae6.png)




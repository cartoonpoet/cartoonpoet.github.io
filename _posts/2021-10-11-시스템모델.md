---
layout: post
title: 시스템 모델
subheading: System Models
author: JunHo
categories: 분산처리
banner: https://bit.ly/32PAjtM
tags: 분산 시스템 네트워크 System distributed issues 정의 시스템 모델
sitemap :
  changefreq : daily
  priority : 1.0







---



## 1. 물리적 모델

---

- 컴퓨터(및 기타 장치) 및 상호 연결 네트워크 측면에서 시스템의 하드웨어 구성
- 컴퓨터의 특정 세부사항과 채택된 네트워킹 기술로부터 추상화하는 분산 시스템의 기본 하드웨어 요소의 표현



### 3세대 분산 시스템

- 초기 분산 시스템, LAN 기술에 대응
- 인터넷 규모의 분산 시스템; 인터넷에 대응
- 현대 분산 시스템
- - 모바일 컴퓨팅의 출현
  - 유키쿼터스 컴퓨팅의 출현
  - 클라우드 컴퓨팅의 출현



| 분산 시스템 | Early            | Internet-scale                             | Contemporary                                                 |
| ----------- | ---------------- | ------------------------------------------ | ------------------------------------------------------------ |
| 규모        | 작음             | 큼                                         | 매우 큼                                                      |
| 이질성      | 제한됨           | 플랫폼, 언어 및 미들웨어 측면에서 중요     | 근본적으로 다른 스타일의 아키텍처를 포함하여 추가 차원 도입  |
| 개방성      | 우선 순위가 아님 | 도입된 표준 범위와 함께 중요한 우선 순위   | 복잡한 시스템을 아직 수용할 수 없는 기존 표준의 주요 연구 과제 |
| 서비스 품질 | 태초에           | 도입된 서비스 범위에 따라 중요한 우선 순위 | 복잡한 시스템을 아직 수용할 수 없는 기존 서비스의 주요 연구 어려움 |



## 2. 아키텍처 모델

- 시스템의 구조는 별도로 지정된 구성 요소와 상호 관계의 측면에서 그것의 구조이다.

- 목표 : 구조에 대한 현재 및 미래의 요구를 충족시킬 수 있도록 보장하는 것
- 주요 걱정 : 시스템의 안정성, 관리 용이성, 적응성 및 비용 효율화



### 세가지 접근법

1. 핵심 기본 아키텍처 요소 살펴보기
2. 복합 구조 패턴 조사
3. 위의 아키텍처 스타일에서 나타나는 다양한 스타일의 프로그래밍을 지원할 수 있는 미들웨어 플랫폼을 고려한다.



### 4개 키 질문을 고려한다

- DS의 기본 구성요소를 이해하는 것

A. (통신 엔티티) : 분산 시스템에서 통신하는 엔티티는 무엇입니까?

B. (커뮤니케이션 패러다임) : 어떻게 의사소통을 할 것인가, 더 구체적으로 어떤 커뮤니케이션 패러다임을 사용할 것인가?

C. (규칙과 책임감) : 전체 아키텍처에서 (잠재적으로 변화할) 역할과 책임은 무엇인가?

D. (배치) : 물리적 분산 인프라에 어떻게 매핑되나? (배치는 무엇인가?)





### 1. Processes

- 분산시스템에 대한 지배적인 과점
- 적절한 프로세스 간 커뮤니케이션 패러다임 결합
- 주의사항
- - 센서 네트워크와 같은 일부 원시 환경에서는 기본 운영체제가 프로세스 추상화를 지원하지 않을 수 있으므로 이러한 시스템의 실체는 노드이다.
  - 대부분의 분산 시스템 환경에서는 프로세스를 쓰레드로 보완



### 2. Objects

- 주어진 문제 영역의 자연 분해 단위를 나타내는 많은 상호작용하는 개체로 구성된다.
- 인터페이스를 통해 액세스
- 객체에 정의한 방법의 명세서를 제공하는 관련 인터페이스 정의 언어 (IDL)



### 3. Components

- 문제 중심의 추상화를 제공하고 인터페이스를 통해 액세스된다는 점에서 객체와 유사하다.
- 구성요소는 인터페이스뿐만 아니라 구성요소가 그 기능을 수행하기 위해 존재해야 하는 다른 구성요소/인터페이스 측면에서 수행하는 가정도 명시한다.
- 모든 의존성을 명시하고 시스템 구축을 위한 보다 완전한 계약을 제공한다.



### 4. Web services

- 인터페이스를 통한 행동 및 액세스 캡슐화에 기반한 접근 방식
- 웹 서비스는 웹 표준을 사용하여 서비스를 표현하고 발견하는 월드 와이드 웹에 본질적으로 통합된다.





## Ch8 분산 개체와 구성요소

---

- 프로그래밍 추상화
- 미들웨어 솔루션
- - 분산 시스템에 대한 상위 수준의 프로그래밍 추상화를 제공하고, 계층화를 통해 기본 인프라의 이질성에 대한 추상화를 제공하여 상호운용성과 휴대성을 제고한다.

- 분산 개체 미들웨어
- - 객체지향 프로그래밍 모델 채택
  - 소통하는 실체는 객체로 표현된다.
  - 물체는 주로 원격 방식 호출(RMI)을 사용하여 통신한다.
  - 캡슐화 및 데이터 추상화
  - Java RMI and CORBA



### RMI(Remote Method Invocation)란?

- 분산되어 존재하는 객체 간의 메시지 전송(메소드를 호출하는 것 포함) 을 가능하게 ㅎ ㅏ는 프로토콜
- RMI자체는 분산 객체 간의 통신을 구현하는 모든 프로토콜을 의미한다.



### RPC(Remote Procedure Call)란?

- UNIX에서 가장 많이 쓰는 통신 프로토콜
- 네트워크에 연결되어 있는 다른 컴퓨터에 존재하는 함수를 실행해, 분산시스템 구현
- 객체지향이 아닌 순차적인 언어로 개발된 애플리케이션의 함수만을 호출





### 컴포넌트 기반 미들웨어

- 분산 개체 미들웨어의 한계를 극복하기 위해
- (암시적 의존성) : 객체 인터페이스에서는 객체의 구현이 무엇에 의존하는지 기술하지 않으므로 객체 기반 시스템을 개발(특히 타사 개발자의 경우)하여 관리하기 어렵다.
- (프로그래밍 복잡성) : 분산 개체 미들웨어를 프로그래밍하면 미들웨어 구현과 관련된 많은 낮은 수준의 디테일을 마스터할 필요가 있다.
- (배포 우려 분리 부족) : 애플리케이션 개발자는 보안, 장애처리, 동시성 등 애플리케이션 간 유사성이 큰 세부 사항을 고려해야 한다.
- (구축 지원 없음) : 객체 기반 미들웨어는 객체 구성구축에 대한 지원을 거의 또는 전혀 제공하지 않음
- 엔터프라이즈 JavaBeans 및 프랙탈



## Ch9 웹 서비스

---

- 클라이언트가 웹 브라우저보다 더 일반적인 방식으로 서버와 상호작용할 수 있는 서비스 인터페이스를 제공한다.
- 클라이언트는 XML로 포맷되어 HTTP로 전송되는 요청 및 회신을 통해 웹 서비스 인터페이스에서의 작업에 접속한다

- URI(Uniform Resource Identifier)로 식별된다.
- - 자원의 명확한 식별을 위해 설계된 일련의 문자
  - URI의 가장 일반적인 형태는 웹주소로 자주 언급되는 Uniform Resource Locator(URL)이다.
- 인터넷 전반의 어플리케이션에서 쉽게 사용가능



### SOAP(originally Simple Object Access Protocol)

- 우리가 흔히 하는 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜
- 전산망에서의 웹서비스 구현에 있어 구조화된 정보교환을 위한 메시징 프로토콜 규격
- 확장성, 중립성, 독립성을 유도하는 것이 목적
- 메시지 형식에 XML 정보 셋을 사용하고, 메시지 협상 및 전송을 위해 주로 HTTP 또는 SMTP와 같은 응용 계층 프로토콜에 의존한다





## B 커뮤니케이션 패러다임

---

1. 상호 프로세스 소통

- 메시지 전달 기본 요소를 포함한 프로세스 간 통신에 대한 비교적 낮은 수준의 지원, 인터넷 프로토콜이 제공하는 API에 대한 직접 액세스(소켓 프로그래밍)
- 프로세스 : 호스트 내에서 실행 중인 프로그램
- - 동일한 호스트 내에서 두 프로세스가 프로세스 간 통신(IPC)을 사용하여 통신함
  - 서로 다른 호스트의 프로세스 간에 메시지 교환으로 통신
- 클라이언트 프로세스 : 커뮤니케이션을 시작하는 프로세스
- 서버 프로세스 : 요청을 기다리는 프로세스





### 소켓 프로그래밍

- 소켓에서 메시지를 보내고 받는 프로세스
- 문과 유사한 소켓
- 프로세스 밀치기 메시지 전송
- 전송 프로세스는 수신 프로세스 시 소켓에 메시지를 전달하기 위해 문의 다른 쪽에 있는 전송 인프라에 의존한다.



2. 원격 호출

- 가장 공통적인 커뮤니케이션 패러다임
- a. 응답 요청 프로토콜
- - 클라이언트-서버 컴퓨팅을 지원하기 위해 기본 메시지 전송 서비스에 적용되는 패턴
  - 오히려 원시적이고 실제로 임베디드 시스템에서만 사용되며 HTTP 프로토콜에도 사용된다.
- b. 원격 프로시저 호출(RPC)
- - 로컬 주소 공간에서 절차처럼 호출
  - 분배의 중요한 측면을 숨김
  - (최소한) 액세스 및 위치 투명성 제공
- c. 원격 메서드 호출(RMI)
- - RPC와 유사하지만 분산 객체의 세계



3. 간접 커뮤니케이션

- 제 3의 실체를 통해 송신자와 수신자 간의 강력한 디커플링(분리) 허용
- - 공간 분리 - 보내는 사람이 누구에게 보낼 지 알 필요가 없다
- - 시간 분리 - 송신자와 수신자가 동시에 존재할 필요 없음

3. a. 그룹 커뮤니케이션

- 1: N 커뮤니케이션을 지원하는 1 : N 커뮤니케이션 패러다임
- 발신자는 그룹 식별자로 그룹에게 메시지를 보내므로 수신자를 알 필요가 없다.

3. b. Publish-subscribe systems

![K-005](https://user-images.githubusercontent.com/38898759/136797435-424c3e17-ce2c-499c-b990-a1ffe47f4a9a.png)

- 정보 수집 시스템
- 다수의 생산자(또는 출판사)가 관심 있는 정보 항목(사건, 카프카의 주제)을 유사한 수의 소비자(또는 구독자)에게 배포한다.
- 1:N 커뮤니케이션 스타일을 제공



3. c. 메시지 큐

- 점대점 서비스를 제공한다.
- 큐는 생산자와 소비자 프로세스들 사이의 리다이렉션을 제공한다.



- poll : 데이터가 왔는지 확인

![K-006](https://user-images.githubusercontent.com/38898759/136797441-9bb0ed10-b134-438a-aff7-753d723755b6.png)

d. 튜플 공간

- 프로세스들은 튜플이라 불리는 임의의 구조적 데이터 항목을 영구 튜플 공간에 배치할 수 있다.
- 다른 프로세스들은 관심 패턴을 지정함으로써 튜플 공간에서 그러한 튜플을 읽거나 제거할 수 있다.



e. 분산 공유 메모리 (DSM)

- 공유 데이터에 대해 추상화를 제공한다.
- 여러 메모리를 하나의 메모리처럼 보여주게끔

![K-007](https://user-images.githubusercontent.com/38898759/136797444-b37c1b57-ded3-49a7-8501-3f6df109f741.png)

- 물리적 메모리를 공유하지 않는 프로세스 간에 데이터를 공유하기 위한 추상화를 제공한다.
- 기본 인프라는 사본이 적시에 제공되도록 보장하고 데이터의 동기화 및 일관성과 관련된 문제도 처리해야 한다.



![K-008](https://user-images.githubusercontent.com/38898759/136797445-ed62f965-3faf-4e46-b6b9-3714e9a2b028.png)



## C Roles and responsibilities

- 개별 프로세스의 역할에서 비롯된 두가지 아키텍처 스타일
- 클라이언트-서버 아키텍처 스타일
- - 클라이언트 프로세스는 잠재적으로 분리된 호스트 컴퓨터에서 개별 서버 프로세스와 상호 작용하여 관리하는 공유 리소스에 액세스합니다.
- - 서버가 다른 서버의 클라이언트가 될 수 있다.
- - 규모가 작다.




---
layout: post
title: 4장 레지스터 전송과 마이크로연산
subheading: Register Transfer and Micro-operations
author: JunHo
categories: 컴퓨터구조
banner: https://bit.ly/32PAjtM
tags: 컴퓨터구조 register micro transfer operation
sitemap :
  changefreq : daily
  priority : 1.0





---













# 4.1 레지스터 전송 언어

---

## Simple Digital Systems

- 디지털 시스템은 디지털 하드웨어 모듈간의 상호 연결이다. 디지털 하드웨어 모듈은 구체적인 정보 처리 업무를 수행한다.
- 모듈들은 레지스터, 디코더, 산술 연산 요소, 제어 논리와 같은 디지털 컴포넌트로 이루어져 있다.
- 모듈들은 simple digital systems를 만드는데 사용될 수 있다.
- 디지털 컴퓨터의 낮은 수준의 구성요소다.
- - 다양한 모듈이 공통 데이터 및 제어 경로와 상호 연결되어 디지털 컴퓨터 시스템을 형성합니다.



마이크로 연산 : 레지스터에 저장된 데이터를 가지고 실행되는 동작(shift, load, clear, inclement)

레지스터 전송 언어 : 레지스터간의 마이크로 연산 전송을 보다 간단하고 명료하게 표시하기 위하여 사용하는 기호이다. 이것은 디지털 컴퓨터의 내부 조직을 상세하게 나타내는 수단으로도 이요되는 한편 디지털 시스템의 설계도 편리하게 해준다.



디지털 시스템은 그안에 포함되어 있는 레지스터와 레지스터에 저장되어 있는 데이터들의 연산들로 정의될 수 있다.



## 디지털 시스템에 대해 잘 정의하기 위해 어떤 동작들을 하는가?

- 레지스터에 저장된 데이터가 수행되는 연산들이 무엇인가?
- 레지스터들 사이에 정보가 전달될 때 무슨 정보가 전달되는가?





## 디지털 컴퓨터의 구조

- 컴퓨터의 (내부) 조직을 정의한다.
- 레지스터 및 레지스터 기능 세트
- 마이크로 오퍼레이션 집합 : 컴퓨터 조직이 제공하는 마이크로 오퍼레이션 집합
- 마이크로 작동 시퀀스를 시작하는 신호 제어





### 레지스터 전송언어 (RTL : Register Transfer Language)

- 기호를 사용하는 언어
- 디지털 컴퓨터에서 내부 구조를 설명하기 위해 사용하는 편리한 도구
- 디지털 시스템의 절차를 설계하는데 쉬워질 수 있다.









# 4.2 Register Transfer

---

- 레지스터는 대문자로 지정되며, 때로는 번호가 뒤따른다.
- 레지스터는 단일 엔티티로 볼 수 있다.
- 다음과 같이 나타냄
- - MAR : Memory Address Register
  - PC : Program Counter
  - IR : Instruction Register



## 레지스터 표현 방법

- 하나의 레지스터 표현
- 레지스터를 분할
- 레지스터에 각각 저장되어 있는 비트들

 ![K-046](https://user-images.githubusercontent.com/38898759/114415317-8a4eba80-9bea-11eb-80a9-328883ec8ad9.jpg)



R2 <- R1 : R1에 있는 데이터를 R2로 옮겨라



### 조건 전송(Conditional Transfer)

- 어떤 조건이 참인 경우에만 발생되는 동작을 의미한다.
- 디지털 컴퓨터에서 이러한 것은 제어 신호로 동작되게끔 한다. 제어 함수라고도 불림
- - RTL에서는 신호가 1일때만 동작한다.
- P : R2 <- R1 : P에 해당하는 값이 1이면 R1에 해당하는 내용을 R2로 전송하라

- P에 해당하는 값은 0 or 1만 가질 수있다.



![K-047](https://user-images.githubusercontent.com/38898759/114419767-af452c80-9bee-11eb-9b5a-2c642441ac4b.jpg)









# 4.3 버스와 메모리 전송

- 전형적인 디지털 컴퓨터는 많은 레지스터와 레지스터들 사이의 정보 전송을 위한 경로를 가지고 있다. 그런데 각각의 레지스터들이 모두 독립된 전송 라인을 사용한다면 그 숫자가 너무 많아지기 때문에, 공통의 버스 시스템이라는 보다 효율적인 방법을 사용한다.

- N개의 레지스터들을 연결하려면 = n(n-1) / 2 lines
- O(n^2) 비용이 발생
- - 디지털 시스템이 커졌을 때 말도 안되는 접근

- 버스는 여러 선들의 묶음이다.

- 어떤 레지스터로부터 버스로 정보를 전달하고 싶다면 : BUS <- R

- R2<-C = BUS <- C (select C), R2<-BUS (Load R2)

- 버스의 정보를 많은 목적 레지스터 중에서 하나로 전송하기 위해서는 버스 라인을 모든 레지스터에 연결하고 로드 제어를 통해 특정한 목적 레지스터를 선택하면 된다.



## 3-상태 버스 버퍼

- 버스 시스템은 멀티플렉서 대신 3-상태 게이트를이용하여 구성할 수도 있다.
- 두 개의 상태 : 논리 0과 1 상태
- 세번째 상태 : 고저항 상태
- - 고저항 상태는 개회로와 같은 상태이기 때문에출력이 차단되어 아무런 논리적 값을 갖지 못한다.
- 3-상태 게이트는 어떠한 것도 가능하다 주로 버퍼가 많이 사용된다.

![K-048](https://user-images.githubusercontent.com/38898759/114424342-f9c8a800-9bf2-11eb-961f-df53e7976d27.jpg)

- 제어 입력이 1일 때는 보통의 버퍼와 같이 동작하여 그 출력은 입력과 동일한 값을 가지고, 제어 입력이 0일 때는 출력이 끊어지고 게이트는 고저항 상태가 된다. 고저항 상태의 특성 때문에 로딩 효과에 대한 염려없이 하나의 라인에 여러 개의 3-상태 게이트 출력을 연결하여 공통 버스 라인을 구성할 수 있다.





## 버스를 구성하는 두가지 방법

- 멀티플렉서를 이용한 방식
- 3-상태 버스 버퍼를 이용한 방식





## 메모리 전송(Memory (RAM) transfer)

- 메모리 워드는 M으로 나타내며, 주소는 M 다음의 각 괄호 안에 표시한다.
- 메모리의 주소를 주소 레지스터(address register, AR)로부터 받고 데이터를 데이터 레지스터9data register, DR)에 전송하는 읽기 동작을 기호로 나타내면 다음과 같다.

- - Read : DR<-M[AR]
- 레지스터 R1에 있는 데이터를 AR에서 지정된 메모리 주소로 전송하는 쓰기 동작은 다음과 같다.
- - Write : M[AR] <- R1

![K-049](https://user-images.githubusercontent.com/38898759/114428493-3d251580-9bf7-11eb-8a77-7f334641b465.jpg)





## 레지스터 전송 마이크로 연산 요약

| A ← B        | 레지스터 B에 있는 값을 레지스터 A로 전송한다.                |
| ------------ | ------------------------------------------------------------ |
| AR ← DR(AD)  | 레지스터 DR의 AD 위치에 있는 내용을 레지스터 AR로 전송한다.  |
| A ← constant | 이진 상수를 레지스터 A로 전송한다.                           |
| ABUS ← R1    | R1의 내용을 버스 A로 보낸다                                  |
| R2←ABUS      | 버스 A의 내용을 R2로 보낸다.                                 |
| AR           | Address register                                             |
| DR           | Data register                                                |
| M[R]         | 레지스터 R위치에 있는 메모리 워드                            |
| M            | 메모리 M[AR]와 같다.                                         |
| DR←M         | 메모리 읽기 연산 : 메모리 AR에 위치에 저장되어 있는 것을 DR로 전송 |
| M←DR         | 데이터 레지스터에 저장되어 있는 내용을 메모리 AR 로 전송     |









# 4,4 산술 마이크로 연산 (Arithmetic Micro-operations)

---



## 4 타입 마이크로 연산들

- 레지스터 사이에서 이진 정보를 전송하는 레지스터 전송 마이크로 연산
- 레지스터에 저장된 수치 데이터에 대해 산술 연산을 수행하는 산술 마이크로 연산
- 레지스터에 저장된 비수치 데이터에 대해 비트 조작 연산을 수행하는 논리 마이크로 연산
- 레지스터에 저장된 데이터에 대해 시프트 연산을 수행하는 시프트 마이크로 연산



## 산술 마이크로 연산 종류

- 덧셈
- 뺄셈
- 증가
- 감소
- 시프트





## 이진 가산기 (binary adder)

- 임의의 길이를 가진 두 이진수에 대한 덧셈을 수행하는 회로
- 여러 개의 전가산기들을 직렬로 연결하여 이전 것의 캐리(올림) 출력이 다음 것의 캐리로 입력 되도록 구성한다.

![K-050](https://user-images.githubusercontent.com/38898759/114430085-051ed200-9bf9-11eb-9f73-aa1bac65259b.jpg)

- n비트 이진 가산기는 n개의 전가산기로 구성된다.



## 이진 가감산기

- ![K-051](https://user-images.githubusercontent.com/38898759/114432043-313b5280-9bfb-11eb-8189-61de007d6bf6.jpg)
- 이진수의 뺄셈은 일반적으로 2의 보수를 이용한 덧셈으로 계산된다.
- 각 전가산기에 XOR 게이트를 추가하면 덧셈과 뺼셈 연산은 하나의 동일한 회로로 구현될 수 있다.
- 모드(mode) 입력 M이 0이면 가산기로 동작하고 M이 1이면 감산기로 동작한다.
- 각 XOR 게이트의 한 입력은 M에 ㅇ녀결되고, 다른 입력은 B의 각 비트에 연결된다. 



## 이진 인크리멘터(Binary Incrementer)

- ![K-052](https://user-images.githubusercontent.com/38898759/114432088-43b58c00-9bfb-11eb-89f6-a1eb27f1e2e3.jpg)

- 레지스터의 값에 1을 더하는 것
- 이진카운터를 이용하여 쉽게 구현할 수 있다.
- 카운트 enable이 활성화될 때마다 클럭 펄스의 변이에 의해 레지스터의 값이 하나씩 증가하게 된다.

- 그런데 인크리멘트 마이크로 연산이 특정한 레지스터와는 관계없이 조합 회로에 의해 수행되어야 하는 경우가 있다. 이때는 반가산기를 직렬로 연결하여 구현한다.
- 최하위 비트에 해당하는 반가산기의 한 입력은 논리 1이고, 다른 하나는 인크리멘트 되어야 할 숫자의 최하위 비트에 연결된다. 반가산기의 캐리 출력은 다음 반가산기의 입력에 연결되어 A0에서 A3까지의 입력을 1 증가시킨 출력을 만들어낸다.
- - 입력된 이진수가 1111인 경우 출력 캐리가 1이되고, 출력은 0이 된다.
- 위 사진에서 n개의 반가산기를 포함하여 n비트 이진 인크리멘터로 확장될 수 있다.



## 산술회로(Arithmetic Circuit)

- ![K-053](https://user-images.githubusercontent.com/38898759/114432661-e66e0a80-9bfb-11eb-8f8c-d3d8ac1b9500.jpg)
- 가산기에 대한 데이터 입력을 제어함으로써 여러가지 연산을 수행할 수 있다.

- 위 그림에는 두개의 4비트 입력, A, B와 출력 D가 존재한다. 입력 A는 이진 가산기의 X 입력에 직접 연결되지만, 입력 B는 멀티플렉서의 데이터 입력에 연결된다.
- 멀티플렉서는 B와 B의 보수, 그리고 논리 0과 1을 입력 받고 있으며, 두 개의 선택 입력 S1과 S0에 의해 출력을 선택한다.
- 입력 캐리 Cin은 최하위 FA의 캐리 입력에 연결되고, 다른 캐리들은 각각 다음 단계의 FA에 연결된다.









# 4.5 논리 마이크로 연산(Logic Micro-operations)

---

> 레지스터에 저장된 비트열에 대한 이진 연산으로서 각 비트를 독립된 이진변수로 간주하고 연산을 수행한다.
>
> 예) XOR 마이크로 연산은 제어 변수 P가 1일 때, 레지스터 R1와 R2의 각 비트별로 연산이 수행됨을 의미





## OR 마이크로 연산

- 기호 : v, +

- 예 : 0100110 v 1010110 = 1110110

- 게이트 : ![K-064](https://user-images.githubusercontent.com/38898759/114560115-58e7f480-9ca7-11eb-9703-ee674e37b437.jpg)





## AND 마이크로 연산

- 기호 : ^, ㆍ
- 게이트 : ![K-065](https://user-images.githubusercontent.com/38898759/114560251-77e68680-9ca7-11eb-95af-62d858e8ec28.jpg)
- 예 : 0100110 ^ 1010110 = 0000110





## NOT 마이크로 연산

- 기호 : ![K-066](https://user-images.githubusercontent.com/38898759/114561101-3dc9b480-9ca8-11eb-9701-bc62d9494cd9.jpg)
- 게이트 : ![K-067](https://user-images.githubusercontent.com/38898759/114561137-43bf9580-9ca8-11eb-996e-fd8ed159c6e5.jpg)
- 예 : ![K-068](https://user-images.githubusercontent.com/38898759/114561196-50dc8480-9ca8-11eb-90df-ca80249e6ab8.jpg)





## XOR 마이크로 연산

- 기호 : ![K-069](https://user-images.githubusercontent.com/38898759/114561288-6651ae80-9ca8-11eb-9bc2-bba38cf938d2.jpg)
- 게이트 : ![K-070](https://user-images.githubusercontent.com/38898759/114561304-6a7dcc00-9ca8-11eb-9cf0-35c9a7db2182.jpg)
- 예 : ![K-071](https://user-images.githubusercontent.com/38898759/114561354-76698e00-9ca8-11eb-9cf0-c1becb544faf.jpg)





## Selective-set Operation

- OR연산을 사용하여 레지스터의 선택된 비트를 logic-1로 강제 적용하는 데 사용된다.
- 예 : 0100 V 1000 = 1100





## Selective-complement (toggling) Operation

- XOR 연산을 사용하여 레지스터의 선택된 비트를 보완하는데 사용된다.
- 예 : 0001 ![K-069](https://user-images.githubusercontent.com/38898759/114561288-6651ae80-9ca8-11eb-9bc2-bba38cf938d2.jpg) 1000 = 1001





## NAND 마이크로 연산

- 기호 : ![K-072](https://user-images.githubusercontent.com/38898759/114562139-31922700-9ca9-11eb-86c3-0161aa12c175.jpg)
- 게이트 : ![K-073](https://user-images.githubusercontent.com/38898759/114562145-32c35400-9ca9-11eb-89f8-12073994c3e5.jpg)
- 예 : ![K-074](https://user-images.githubusercontent.com/38898759/114562148-33f48100-9ca9-11eb-9e80-3fdce64a3c18.jpg)





## NOR 마이크로 연산

- 기호 : ![K-075](https://user-images.githubusercontent.com/38898759/114562196-41117000-9ca9-11eb-960f-f6544ff9075e.jpg)
- 게이트 : ![K-076](https://user-images.githubusercontent.com/38898759/114562200-41aa0680-9ca9-11eb-8590-32a31d35f4ee.jpg)
- 예 : ![K-077](https://user-images.githubusercontent.com/38898759/114562203-42429d00-9ca9-11eb-8f7f-15f07b20fe57.jpg)



## 삽입 연산

- 레지스터의 선택된 비트를 입력 값으로 강제 적용하는 데 사용된다.

- - 1단계 : 원하는 비트를 마스크한다
  - 원하는 값을 가진 항목을 OR연산한다.

- 예)

- - R1 = 0110 1010 이라고 가정한다. 

  - 가장 왼쪽에 있는 0110을 1001로 바꾸고자 한다.

  - - 1단계 : 0110 1010 ^ 0000 1111 = 0000 1010
    - 2단계 : 0000 1010 v 1001 0000 = 1001 1010
    - -> R1 = 1001 1010

    



## Set(Preset) 마이크로 연산

- 모든 비트가 1로 이루어져 있는 것과 OR 연산을 수행한다.
- 예 : 100110 V 111111 = 111111





## Clear(Reset) 마이크로 연산

- 모든 비트를 0으로 만든다고 생각하면 된다.
- 모든 비트가 0으로 되어 있는 것과 AND 연산을 수행한다.
- 예 : 100110 ^ 000000 = 000000







## 논리마이크로 연산표

![K-078](https://user-images.githubusercontent.com/38898759/114565500-48864880-9cac-11eb-95d0-5bf14b4c17d2.jpg)





## 하드웨어 구현

- 논리 마이크로 연산을 하드웨어로 구현하기 위해서는 각 비트마다 논리 게이트가 필요하며, 대부분의 컴퓨터에서는 16개의 논리 마이크로 연산 중에서 단지 네 개의 연산 AND, OR, XOR, 보수 만을 사용한다.





## 응용

- 논리 마이크로 연산은 레지스터에 저장된 각 비트나 한 워드의 일부분을 처리하는 데 매우 유용하다. 즉, 각 비트를 변경시키거나, 비트 묶음을 제거하거나 새로운 비트 값을 삽입할 수 있다.





## Selective-Set Operation

![K-079](https://user-images.githubusercontent.com/38898759/114568421-11656680-9caf-11eb-9587-c6750b14bf99.jpg)

- 만약 B에 있는 비트가 1인 부분은 같은 위치에 있는 것도 1이다. 그렇지 않으면 유지한다.





## Selective-Complement Operation

![K-080](https://user-images.githubusercontent.com/38898759/114568545-2cd07180-9caf-11eb-9a16-da1cb2323581.jpg)

- B에서 특정한 비트가 1로 되어있다면 같은 위치에 있는 A의 값이 보수되서 출력된다. 그렇지 않은 것은 변하지 않는다.





## Selective-Clear Operation

- Selective-set 연산과 비슷하다, 어떤 것을 선택해서 선택한 비트만 0으로 만들어 준다.
- B에 저장된 비트 패턴에 따라서 A에 있는 비트를 0으로 변경한다.

![K-082](https://user-images.githubusercontent.com/38898759/114569292-cc8dff80-9caf-11eb-85a9-bfbb2edac198.jpg)

- B에 있는 특정한 비트가 1이라면 A의 같은 위치에 있는 것들은 0으로 변경된다. 그렇지 않은 것은 변경되지 않는다.





## Mask 연산

- 내가 다른 값을 삽입하거나 지우고 싶다면 해당 B 비트값을 0으로 변경한다.
- ![K-083](https://user-images.githubusercontent.com/38898759/114569546-0bbc5080-9cb0-11eb-9616-0c1605438898.jpg)
- B에 있는 어떤 비트가 0이면, A에 있는 같은 위치에 있는 것은 0으로 변경되고 그렇지 않은 것은 유지된다.





## Insert 연산

- 특정 비트패턴을 A 레지스터에 전달하는 것, 그 비트를 제외한 나머지 비트는 전달되지 않도록 한다.
- 바꾸고 싶은 비트 위치에 있는 것을 0으로 변경한다.
- 새 비트를 원하는 위치에 OR연산한다.





## 클리어(clear) 연산

- A와 B를 비교하여 두 개의 워드가 일치하면 A를 0으로 세트하는 연산
- 1010 XOR 1010 = 0000





# 시프트 마이크로 연산

---

- 데이터의 직렬 전송을 위해 사용되며, 산술이나 논리 연산 및 다른 데이터 처리 동작과 연계하여 사용될 수 있다.
- 레지스터의 내용은 왼쪽 및 오른쪽으로 시프트 될 수 있으며, 비트들이 시프트될 때 첫 번째 플립플롭은 직렬 입력을 통해 새로운 이진 정보를 받아 들일 수 있다.



## 시프트 연산 종류

### 논리 시프트

- 직렬 입력으로 0이 전송되는 것
- 기호 : shl, shr
- 예 : R1 ← shl R1 = 왼쪽으로 시프트한다. 
- 예 : R2 ← shr R2 = 오른쪽으로 시프트한다.



### 순환 시프트

- 시프트 레지스터의 직렬 출력을 직렬 입력에 연결함으로써 원래 저장되어 있던 정보의손실 없이 비트들을 순환시키는 연산
- 기호 : cil, cir



### 산술 시프트

- 부호가 있는 이진수를 시프트 하는 것
- 왼쪽 산술 시프트는 이진수에 2를 곱한 것이고, 오른쪽 산술 시프트는 2로 나눈 것과 같다.
- 산술 시프트에서 이진수의 맨 왼쪽 비트는 부호비트 이므로 시프트되지 않는다.
- 오른쪽으로 산술 시프트시 부호비트는 그대로 있고 그 이전 비트부터 오른쪽으로 시프트되어 첫 비트 값을 잃어버리게 된다.
- 왼쪽 산술 시프트시 첫 비트에 0을 삽입하고, 나머지 상위 비트들은 모두 왼쪽으로 시프트한다. 오버 플로 감지하는 방법은 다음과 같다. V_s = R_n-1 XOR R_n-2





## 하드웨어 구현

![K-084](https://user-images.githubusercontent.com/38898759/114572240-46bf8380-9cb2-11eb-80a3-3066582cf60c.jpg)

- 많은 레지스터를 가진 프로세서 장치에서는 조합 회로를 이용하여 시프트 연산을 구현하는 것이 더 효율적이다. 왜냐하면 조합 회로 시프터는 하나의 클럭 펄스만을 필요하기 때문
- 즉 시프트될 레지스터의 내용을 조합 회로 시프트에 연결된 공통의 버스에 올려놓은 다음, 시프트된 값을 클럭 펄스에 의해 원래의 레지스터로 다시 로딩하는 방법을 사용한다.
- 선택 신호가 0이면 오른쪽으로(그림에서 아래 방향)으로 시프트되고, 선택 신호가 1이면 입력 데이터는 왼쪽(그림에서 위방향) 으로 시프트 된다.





# 4.7 산술 논리 시프트 장치

---

![K-085](https://user-images.githubusercontent.com/38898759/114572675-a9b11a80-9cb2-11eb-9a0e-f6a3043f98bc.jpg)

- 컴퓨터에서는 각 마이크로 연산마다 독립된 레지스터를 두는 대신에 산술 논리 장치(ALU)라고 하는 공용 연산 장치에 연결된 레지스터 그룹을 사용한다.
- 마이크로 연산 수행 순서
- 1. 지정된 레지스터의 내용을 ALU의 입력에 올려놓는다.
  2. ALU가 정해진 연산을 수행하고 결과가 나오면 그것을 목적 레지스터로 전송한다.
- ALU는 조합 회로로 구성되어 있기 때문에 근원 레지스터에서 ALU를 통하여 목적 레지스터까지의 데이터 전송이 하나의 클럭 펄스 기간 동안에 수행된다. 일반적으로 시프트 마이크로 연산은 별도의 장치에서 수행되지만, 가끔은 ALU의 한 부분으로 구현되기도 한다.
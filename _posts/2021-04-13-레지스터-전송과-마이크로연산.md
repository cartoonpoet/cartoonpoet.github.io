---
layout: post
title: 4장 레지스터 전송과 마이크로연산
subheading: Register Transfer and Micro-operations
author: JunHo
categories: 컴퓨터구조
banner: https://bit.ly/32PAjtM
tags: 컴퓨터구조 register micro transfer operation
sitemap :
  changefreq : daily
  priority : 1.0





---









# 4.1 레지스터 전송 언어

---

## Simple Digital Systems

- 디지털 시스템은 디지털 하드웨어 모듈간의 상호 연결이다. 디지털 하드웨어 모듈은 구체적인 정보 처리 업무를 수행한다.
- 모듈들은 레지스터, 디코더, 산술 연산 요소, 제어 논리와 같은 디지털 컴포넌트로 이루어져 있다.
- 모듈들은 simple digital systems를 만드는데 사용될 수 있다.
- 디지털 컴퓨터의 낮은 수준의 구성요소다.
- - 다양한 모듈이 공통 데이터 및 제어 경로와 상호 연결되어 디지털 컴퓨터 시스템을 형성합니다.



마이크로 연산 : 레지스터에 저장된 데이터를 가지고 실행되는 동작(shift, load, clear, inclement)

레지스터 전송 언어 : 레지스터간의 마이크로 연산 전송을 보다 간단하고 명료하게 표시하기 위하여 사용하는 기호이다. 이것은 디지털 컴퓨터의 내부 조직을 상세하게 나타내는 수단으로도 이요되는 한편 디지털 시스템의 설계도 편리하게 해준다.



디지털 시스템은 그안에 포함되어 있는 레지스터와 레지스터에 저장되어 있는 데이터들의 연산들로 정의될 수 있다.



## 디지털 시스템에 대해 잘 정의하기 위해 어떤 동작들을 하는가?

- 레지스터에 저장된 데이터가 수행되는 연산들이 무엇인가?
- 레지스터들 사이에 정보가 전달될 때 무슨 정보가 전달되는가?





## 디지털 컴퓨터의 구조

- 컴퓨터의 (내부) 조직을 정의한다.
- 레지스터 및 레지스터 기능 세트
- 마이크로 오퍼레이션 집합 : 컴퓨터 조직이 제공하는 마이크로 오퍼레이션 집합
- 마이크로 작동 시퀀스를 시작하는 신호 제어





### 레지스터 전송언어 (RTL : Register Transfer Language)

- 기호를 사용하는 언어
- 디지털 컴퓨터에서 내부 구조를 설명하기 위해 사용하는 편리한 도구
- 디지털 시스템의 절차를 설계하는데 쉬워질 수 있다.





# 4.2 Register Transfer

---

- 레지스터는 대문자로 지정되며, 때로는 번호가 뒤따른다.
- 레지스터는 단일 엔티티로 볼 수 있다.
- 다음과 같이 나타냄
- - MAR : Memory Address Register
  - PC : Program Counter
  - IR : Instruction Register



## 레지스터 표현 방법

- 하나의 레지스터 표현
- 레지스터를 분할
- 레지스터에 각각 저장되어 있는 비트들

 ![K-046](https://user-images.githubusercontent.com/38898759/114415317-8a4eba80-9bea-11eb-80a9-328883ec8ad9.jpg)



R2 <- R1 : R1에 있는 데이터를 R2로 옮겨라



### 조건 전송(Conditional Transfer)

- 어떤 조건이 참인 경우에만 발생되는 동작을 의미한다.
- 디지털 컴퓨터에서 이러한 것은 제어 신호로 동작되게끔 한다. 제어 함수라고도 불림
- - RTL에서는 신호가 1일때만 동작한다.
- P : R2 <- R1 : P에 해당하는 값이 1이면 R1에 해당하는 내용을 R2로 전송하라

- P에 해당하는 값은 0 or 1만 가질 수있다.



![K-047](https://user-images.githubusercontent.com/38898759/114419767-af452c80-9bee-11eb-9b5a-2c642441ac4b.jpg)





# 4.3 버스와 메모리 전송

- 전형적인 디지털 컴퓨터는 많은 레지스터와 레지스터들 사이의 정보 전송을 위한 경로를 가지고 있다. 그런데 각각의 레지스터들이 모두 독립된 전송 라인을 사용한다면 그 숫자가 너무 많아지기 때문에, 공통의 버스 시스템이라는 보다 효율적인 방법을 사용한다.

- N개의 레지스터들을 연결하려면 = n(n-1) / 2 lines
- O(n^2) 비용이 발생
- - 디지털 시스템이 커졌을 때 말도 안되는 접근

- 버스는 여러 선들의 묶음이다.

- 어떤 레지스터로부터 버스로 정보를 전달하고 싶다면 : BUS <- R

- R2<-C = BUS <- C (select C), R2<-BUS (Load R2)

- 버스의 정보를 많은 목적 레지스터 중에서 하나로 전송하기 위해서는 버스 라인을 모든 레지스터에 연결하고 로드 제어를 통해 특정한 목적 레지스터를 선택하면 된다.



## 3-상태 버스 버퍼

- 버스 시스템은 멀티플렉서 대신 3-상태 게이트를이용하여 구성할 수도 있다.
- 두 개의 상태 : 논리 0과 1 상태
- 세번째 상태 : 고저항 상태
- - 고저항 상태는 개회로와 같은 상태이기 때문에출력이 차단되어 아무런 논리적 값을 갖지 못한다.
- 3-상태 게이트는 어떠한 것도 가능하다 주로 버퍼가 많이 사용된다.

![K-048](https://user-images.githubusercontent.com/38898759/114424342-f9c8a800-9bf2-11eb-961f-df53e7976d27.jpg)

- 제어 입력이 1일 때는 보통의 버퍼와 같이 동작하여 그 출력은 입력과 동일한 값을 가지고, 제어 입력이 0일 때는 출력이 끊어지고 게이트는 고저항 상태가 된다. 고저항 상태의 특성 때문에 로딩 효과에 대한 염려없이 하나의 라인에 여러 개의 3-상태 게이트 출력을 연결하여 공통 버스 라인을 구성할 수 있다.





## 버스를 구성하는 두가지 방법

- 멀티플렉서를 이용한 방식
- 3-상태 버스 버퍼를 이용한 방식





## 메모리 전송(Memory (RAM) transfer)

- 메모리 워드는 M으로 나타내며, 주소는 M 다음의 각 괄호 안에 표시한다.
- 메모리의 주소를 주소 레지스터(address register, AR)로부터 받고 데이터를 데이터 레지스터9data register, DR)에 전송하는 읽기 동작을 기호로 나타내면 다음과 같다.

- - Read : DR<-M[AR]
- 레지스터 R1에 있는 데이터를 AR에서 지정된 메모리 주소로 전송하는 쓰기 동작은 다음과 같다.
- - Write : M[AR] <- R1

![K-049](https://user-images.githubusercontent.com/38898759/114428493-3d251580-9bf7-11eb-8a77-7f334641b465.jpg)





## 레지스터 전송 마이크로 연산 요약

| A ← B        | 레지스터 B에 있는 값을 레지스터 A로 전송한다.                |
| ------------ | ------------------------------------------------------------ |
| AR ← DR(AD)  | 레지스터 DR의 AD 위치에 있는 내용을 레지스터 AR로 전송한다.  |
| A ← constant | 이진 상수를 레지스터 A로 전송한다.                           |
| ABUS ← R1    | R1의 내용을 버스 A로 보낸다                                  |
| R2←ABUS      | 버스 A의 내용을 R2로 보낸다.                                 |
| AR           | Address register                                             |
| DR           | Data register                                                |
| M[R]         | 레지스터 R위치에 있는 메모리 워드                            |
| M            | 메모리 M[AR]와 같다.                                         |
| DR←M         | 메모리 읽기 연산 : 메모리 AR에 위치에 저장되어 있는 것을 DR로 전송 |
| M←DR         | 데이터 레지스터에 저장되어 있는 내용을 메모리 AR 로 전송     |





# 4,4 산술 마이크로 연산 (Arithmetic Micro-operations)

---



## 4 타입 마이크로 연산들

- 레지스터 사이에서 이진 정보를 전송하는 레지스터 전송 마이크로 연산
- 레지스터에 저장된 수치 데이터에 대해 산술 연산을 수행하는 산술 마이크로 연산
- 레지스터에 저장된 비수치 데이터에 대해 비트 조작 연산을 수행하는 논리 마이크로 연산
- 레지스터에 저장된 데이터에 대해 시프트 연산을 수행하는 시프트 마이크로 연산



## 산술 마이크로 연산 종류

- 덧셈
- 뺄셈
- 증가
- 감소
- 시프트





## 이진 가산기 (binary adder)

- 임의의 길이를 가진 두 이진수에 대한 덧셈을 수행하는 회로
- 여러 개의 전가산기들을 직렬로 연결하여 이전 것의 캐리(올림) 출력이 다음 것의 캐리로 입력 되도록 구성한다.

![K-050](https://user-images.githubusercontent.com/38898759/114430085-051ed200-9bf9-11eb-9f73-aa1bac65259b.jpg)

- n비트 이진 가산기는 n개의 전가산기로 구성된다.



## 이진 가감산기

- ![K-051](https://user-images.githubusercontent.com/38898759/114432043-313b5280-9bfb-11eb-8189-61de007d6bf6.jpg)
- 이진수의 뺄셈은 일반적으로 2의 보수를 이용한 덧셈으로 계산된다.
- 각 전가산기에 XOR 게이트를 추가하면 덧셈과 뺼셈 연산은 하나의 동일한 회로로 구현될 수 있다.
- 모드(mode) 입력 M이 0이면 가산기로 동작하고 M이 1이면 감산기로 동작한다.
- 각 XOR 게이트의 한 입력은 M에 ㅇ녀결되고, 다른 입력은 B의 각 비트에 연결된다. 



## 이진 인크리멘터(Binary Incrementer)

- ![K-052](https://user-images.githubusercontent.com/38898759/114432088-43b58c00-9bfb-11eb-89f6-a1eb27f1e2e3.jpg)

- 레지스터의 값에 1을 더하는 것
- 이진카운터를 이용하여 쉽게 구현할 수 있다.
- 카운트 enable이 활성화될 때마다 클럭 펄스의 변이에 의해 레지스터의 값이 하나씩 증가하게 된다.

- 그런데 인크리멘트 마이크로 연산이 특정한 레지스터와는 관계없이 조합 회로에 의해 수행되어야 하는 경우가 있다. 이때는 반가산기를 직렬로 연결하여 구현한다.
- 최하위 비트에 해당하는 반가산기의 한 입력은 논리 1이고, 다른 하나는 인크리멘트 되어야 할 숫자의 최하위 비트에 연결된다. 반가산기의 캐리 출력은 다음 반가산기의 입력에 연결되어 A0에서 A3까지의 입력을 1 증가시킨 출력을 만들어낸다.
- - 입력된 이진수가 1111인 경우 출력 캐리가 1이되고, 출력은 0이 된다.
- 위 사진에서 n개의 반가산기를 포함하여 n비트 이진 인크리멘터로 확장될 수 있다.



## 산술회로(Arithmetic Circuit)

- ![K-053](https://user-images.githubusercontent.com/38898759/114432661-e66e0a80-9bfb-11eb-8f8c-d3d8ac1b9500.jpg)
- 가산기에 대한 데이터 입력을 제어함으로써 여러가지 연산을 수행할 수 있다.

- 위 그림에는 두개의 4비트 입력, A, B와 출력 D가 존재한다. 입력 A는 이진 가산기의 X 입력에 직접 연결되지만, 입력 B는 멀티플렉서의 데이터 입력에 연결된다.
- 멀티플렉서는 B와 B의 보수, 그리고 논리 0과 1을 입력 받고 있으며, 두 개의 선택 입력 S1과 S0에 의해 출력을 선택한다.
- 입력 캐리 Cin은 최하위 FA의 캐리 입력에 연결되고, 다른 캐리들은 각각 다음 단계의 FA에 연결된다.



# 4.5 논리 마이크로 연산(Logic Micro-operations)